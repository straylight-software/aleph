# RFC-010: Aleph-1

## Abstract

A build system where derivations are Dhall data, builders are Haskell programs, and Nix/Buck2 are executors. No env vars, no string parsing, no stdenv. Typed composition from package definition to bytes on disk.

## Status

Draft

## Motivation

### The Problem

Nix builds are:
- Slow (no incrementality, no remote execution)
- Stringly-typed (`buildPhase = "make"`)
- Implicit (stdenv injects hundreds of dependencies)
- Opaque (fail in postFixup after 2 hours)

Buck2/Bazel builds are:
- Fast (incremental, cacheable, remote-exec)
- Unportable (autodetect host toolchains)
- Uncomposable (no overlays, fork to modify)
- Opinionless (prelude is "figure it out yourself")

We've been trying to fix this by:
1. Generating Dhall from Haskell (wrong direction)
2. Parsing env vars in builders (stringly-typed again)
3. Wrapping stdenv (still stdenv)

### The Insight

From the Weyl Build algebra (Lean proof):

```
Cache key = coset, not bundle
Same coset → same outputs, regardless of backend
```

Nix and Buck2 are both *executors*. The *algebra* is:
- **Derivations as data** (Dhall)
- **Builders as programs** (Haskell)
- **Composition via records** (`//` is overlay)

The cache key is the content hash of the Dhall spec, not the Nix derivation hash. Same spec → same build, whether Nix or Buck2 executes it.

## Design

### Layer 1: Dhall Schema (`nix/Drv/`)

Types for everything. No strings except names and paths.

```dhall
-- Sum types for configuration
let Linkage = < Static | Shared | Both >
let BuildType = < Release | Debug | RelWithDebInfo | MinSizeRel >
let LTO = < Off | Thin | Full >

-- Real triples
let Triple = { arch : Arch, vendor : Vendor, os : OS, abi : ABI }

-- Build system selection
let Build = < CMake : CMake | Autotools : Autotools | Meson : Meson | ... >

-- The package
let Package = {
  name : Text,
  version : Text,
  src : Src,
  deps : List Text,      -- package names, resolved later
  build : Build,
  host : Triple,
  target : Optional Triple,
  checks : List Text
}
```

Overlays are record updates:

```dhall
let zlib-static = zlib // { 
  build = zlib.build // { linkage = Linkage.Static } 
}
```

### Layer 2: Build Context (`BuildContext.dhall`)

Generated at build time. The *only* input to the builder.

```dhall
-- Generated by Nix (or Buck2), consumed by builder
{ out : Text                           -- output path
, src : Text                           -- source path
, host : Triple                        -- build machine
, target : Optional Triple             -- cross-compilation target
, cores : Natural                      -- parallelism
, deps : Map Text Text                 -- name → store path
, spec : Package                       -- the package being built
}
```

No `ALEPH_DEPS`. No `$stdenv/setup`. No env vars. One typed file.

### Layer 3: Haskell Builders (`nix/builders/`)

Real programs that read Dhall, execute builds.

```haskell
-- builders/std/cmake.hs
import Aleph.Build

main :: IO ()
main = do
  ctx <- Dhall.input auto =<< getArgs  -- read BuildContext.dhall
  cmake ctx    -- typed: knows deps, flags, paths
  ninja ctx    -- typed: knows parallelism, build dir
```

The `Aleph.Build` library provides:

```haskell
-- Typed context
data Ctx = Ctx
  { out    :: FilePath
  , src    :: FilePath
  , deps   :: Map Text FilePath
  , host   :: Triple
  , target :: Maybe Triple
  , cores  :: Int
  , spec   :: Package
  }

-- Typed operations
cmake :: Ctx -> IO ()      -- reads CMake flags from spec.build
ninja :: Ctx -> IO ()
configure :: Ctx -> IO ()  -- reads Autotools flags from spec.build
make :: Ctx -> IO ()

-- Dep resolution (typed, not string lookup)
dep :: Ctx -> Text -> FilePath
```

### Layer 4: Executors

#### Nix Executor

Nix's job: fetch sources, resolve deps, provide store paths.

```nix
# Simplified - real impl reads Dhall
buildPackage = spec: 
  let
    src = fetchSource spec.src;
    deps = map resolvePackage spec.deps;
    
    buildContext = writeDhallFile "build-context.dhall" {
      inherit src;
      out = placeholder "out";
      deps = listToAttrs (map (d: { name = d.name; value = d.outPath; }) deps);
      spec = spec;
      # ...
    };
  in
  runCommand spec.name {
    inherit src;
    nativeBuildInputs = [ aleph-build ] ++ deps;
  } ''
    aleph-build ${buildContext}
  '';
```

#### Buck2 Executor

Buck2's job: shred the action graph, cache, remote-exec.

```python
# toolchains/BUCK
# Generated from Dhall, points to Nix store paths

load("//rules:aleph.bzl", "aleph_library")

aleph_library(
    name = "zlib-ng",
    spec = "//specs:zlib-ng.dhall",
    build_context = "//specs:zlib-ng-context.dhall",  # generated
)
```

Same Dhall spec, same builder binary, different executor.

### Layer 5: Defaults

The correct defaults for 90% of builds:

```dhall
-- Drv/Defaults.dhall
let Defaults = {
  cc = "clang",
  ccVersion = "22",
  libc = "musl",           -- static, portable
  stdlib = "libc++",
  linkage = Linkage.Static,
  debug = Debug.Full,      -- symbols + source maps
  hardening = Hardening.Off,  -- dev builds
  lto = LTO.Off,           -- fast iteration
  pic = PIC.Default
}
```

Fast: static musl, no dynamic linking overhead.
Secure: no dlopen, no LD_PRELOAD, no RUNPATH.
Portable: runs on any Linux.
Debuggable: full symbols, can read the crash.

Override when you know better:

```dhall
-- Python extension needs PIC and shared
let python-ext-defaults = Defaults // {
  linkage = Linkage.Shared,
  pic = PIC.On
}

-- Release build wants hardening and LTO
let release-defaults = Defaults // {
  hardening = Hardening.Full,
  lto = LTO.Thin,
  debug = Debug.Symbols  -- keep symbols, strip later
}
```

### Data Flow

```
┌──────────────────────────────────────────────────────────────┐
│                         AUTHORING                            │
│                                                              │
│   packages/zlib-ng.dhall                                     │
│        │                                                     │
│        │  imports Drv/Prelude.dhall                          │
│        ▼                                                     │
│   Package { name, version, src, deps, build, ... }           │
│                                                              │
└──────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│                        RESOLUTION                            │
│                                                              │
│   Nix/Buck2 reads Package                                    │
│        │                                                     │
│        ├── resolves deps (names → store paths)               │
│        ├── fetches src                                       │
│        ├── determines host/target                            │
│        ▼                                                     │
│   BuildContext.dhall (generated)                             │
│                                                              │
└──────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌──────────────────────────────────────────────────────────────┐
│                        EXECUTION                             │
│                                                              │
│   aleph-build ./build-context.dhall                          │
│        │                                                     │
│        │  reads typed context                                │
│        │  dispatches on spec.build                           │
│        ▼                                                     │
│   cmake/ninja/make/meson/custom                              │
│        │                                                     │
│        ▼                                                     │
│   $out/lib/libz.a, $out/include/zlib.h, ...                  │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

### No stdenv

stdenv is the universal coset: "I don't know what I need, give me everything."

```nix
# stdenv: implicit, bloated
stdenv.mkDerivation {
  buildPhase = "make";  # assumes $CC, $CXX, $AR, ...
}
```

We have explicit deps:

```dhall
# Explicit: exactly what's needed
{ deps = [ "cmake", "ninja" ]
, build = Build.cmake { ... }
}
```

Different packages, different cosets, better cache hits:

```
stdenv:  cacheKey(any-cmake-pkg) = STDENV_HASH
ours:    cacheKey(zlib) ≠ cacheKey(fmt) ≠ cacheKey(llvm)
```

### No ALEPH_DEPS

Env vars are stringly-typed. The builder reads one file:

```haskell
main = do
  [contextPath] <- getArgs
  ctx <- Dhall.input auto (T.pack contextPath)
  runBuild ctx
```

The context *is* the interface. No `getEnv`, no parsing, no implicit state.

### Buck2 Integration

Starlark stays in its lane (target declaration):

```python
cxx_library(
    name = "foo",
    srcs = glob(["*.cpp"]),
    deps = [":bar"],
)
```

Toolchains come from Dhall:

```dhall
-- Emitted to Starlark
(./Drv/Buck.dhall).toStarlark package
```

Output:
```python
cmake_library(
    name = "zlib-ng",
    version = "2.2.4",
    deps = ["cmake", "ninja"],
    cmake_flags = ["-DZLIB_COMPAT=ON", "-DBUILD_SHARED_LIBS=OFF"],
)
```

Two languages, two jobs:
- **Dhall**: toolchains, configuration, the bundle
- **Starlark**: targets, files, the graph

### Cross Compilation

Real triples, not magic:

```dhall
let pkg = { 
  host = Triple.x86_64-linux-gnu,
  target = Some Triple.aarch64-linux-gnu,
  ...
}
```

The builder handles it:

```haskell
cmake ctx = do
  let crossFlags = case target ctx of
        Nothing -> []
        Just t -> 
          [ "-DCMAKE_SYSTEM_NAME=" <> osName t
          , "-DCMAKE_SYSTEM_PROCESSOR=" <> archName t
          , "-DCMAKE_C_COMPILER=" <> crossCC ctx t
          ]
  run "cmake" (baseFlags ++ crossFlags)
```

Same builder, same code path, cross or native.

## Implementation Plan

### Phase 1: Schema (DONE)

- [x] `Drv/Flags.dhall` - sum types
- [x] `Drv/Triple.dhall` - real triples
- [x] `Drv/Src.dhall` - source fetchers
- [x] `Drv/Build.dhall` - build systems
- [x] `Drv/Package.dhall` - the derivation
- [x] `Drv/Buck.dhall` - Starlark emitter

### Phase 2: Builders (DONE)

- [x] `Aleph.Build` library
- [x] `Aleph.Build.Flags`
- [x] `Aleph.Build.Triple`
- [x] `builders/std/cmake.hs`
- [x] `builders/std/autotools.hs`
- [x] `builders/std/header-only.hs`

### Phase 3: Context (TODO)

- [ ] `Drv/BuildContext.dhall` schema
- [ ] Remove ALEPH_DEPS, read context file
- [ ] Nix generates BuildContext.dhall
- [ ] Test end-to-end: Dhall → Nix → builder → output

### Phase 4: Nix Integration (TODO)

- [ ] `buildFromDhall` function
- [ ] Resolve deps by name
- [ ] Generate BuildContext.dhall
- [ ] Deprecate wasm-plugin.nix path

### Phase 5: Buck2 Integration (TODO)

- [ ] Buck2 rules that consume Dhall
- [ ] Toolchain BUCK files from Dhall
- [ ] Shared cache (same hash = cache hit)
- [ ] Test: Nix-built artifact usable by Buck2

### Phase 6: Defaults (TODO)

- [ ] `Drv/Defaults.dhall`
- [ ] clang-22, musl, static, debug
- [ ] Override patterns documented
- [ ] Python extension profile
- [ ] CUDA profile
- [ ] Release profile

## Alternatives Considered

### Keep WASM path

The current approach compiles Haskell to WASM, loads via `builtins.wasm`. Problems:
- Requires straylight-nix fork
- Haskell emits Dhall (wrong direction)
- Still parses env vars in builder

### Extend stdenv

Could add typed phases to stdenv. Problems:
- Still drags in stdenv's implicit deps
- Universal coset, bad cache
- Bash underneath

### Pure Starlark

Could use Buck2/Bazel Starlark for everything. Problems:
- No composition (overlays)
- Toolchain autodetection
- Crippled language for complex logic

## Security Considerations

- Builders have no network access (sandbox)
- All inputs content-addressed
- No `LD_PRELOAD`, no dynamic loading (static musl)
- Hermetic: only declared deps accessible

## References

- Lean proof: `~/tmp/lean4/weyl-build.lean`
- Working cmake builder: `nix/builders/std/cmake.hs`
- Dhall schema: `nix/Drv/`
- Package examples: `nix/packages-dhall/`
