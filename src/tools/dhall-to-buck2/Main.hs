{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

{- |
Module      : Main
Description : Convert Dhall build targets to Buck2 BUCK files

Takes a BUILD.dhall and emits a BUCK file with proper cxx_binary/cxx_library rules.
Buck2's DICE engine then handles incremental computation, caching, and RE.

Usage:
  dhall-to-buck2 BUILD.dhall > BUCK
  dhall-to-buck2 --dir src/  # process all BUILD.dhall files

The Dhall schema (src/armitage/dhall/Build.dhall) maps to Buck2 rules:
  - cxx-binary → cxx_binary
  - cxx-library → cxx_library  
  - Dep.Flake "nixpkgs#foo" → external dependency (prebuilt)
  - Dep.Local ":bar" → buck2 target dependency

Coeffects become Buck2 execution platform constraints.
-}
module Main where

import Control.Monad (forM_)
import Data.List (intercalate)
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as TIO
import System.Environment (getArgs)
import System.Exit (exitFailure)
import System.IO (hPutStrLn, stderr)

import qualified Dhall
import Dhall (auto, input)

-- | Dhall types (must match src/armitage/dhall/Build.dhall)
data Dep
  = DepLocal Text
  | DepFlake Text
  | DepPkgConfig Text
  | DepExternal Text Text
  deriving (Show)

data Src
  = SrcFiles [Text]
  | SrcFetch Text Text
  | SrcGit Text Text Text
  deriving (Show)

data Resource
  = Pure
  | Network
  | Auth Text
  | Sandbox Text
  | Filesystem Text
  deriving (Show)

data Target = Target
  { targetName :: Text
  , targetSrcs :: Src
  , targetDeps :: [Dep]
  , targetRequires :: [Resource]
  } deriving (Show)

-- | Render a Dhall target as Buck2 Starlark
renderTarget :: Target -> Text
renderTarget Target{..} = T.unlines
  [ "cxx_binary("
  , "    name = " <> quote targetName <> ","
  , "    srcs = " <> renderSrcs targetSrcs <> ","
  , renderDeps targetDeps
  , renderCoeffects targetRequires
  , ")"
  ]

renderSrcs :: Src -> Text
renderSrcs = \case
  SrcFiles fs -> "[" <> T.intercalate ", " (map quote fs) <> "]"
  SrcFetch url hash -> "# TODO: fetch " <> url
  SrcGit url rev hash -> "# TODO: git " <> url

renderDeps :: [Dep] -> Text
renderDeps [] = ""
renderDeps deps = "    deps = [\n" <> T.unlines (map renderDep deps) <> "    ],"
  where
    renderDep = \case
      DepLocal t -> "        " <> quote t <> ","
      DepFlake ref -> "        # nixpkgs: " <> ref
      DepPkgConfig name -> "        # pkg-config: " <> name
      DepExternal hash name -> "        # external: " <> name

renderCoeffects :: [Resource] -> Text
renderCoeffects rs = 
  let labels = concatMap toLabel rs
  in if null labels 
     then ""
     else "    labels = [" <> T.intercalate ", " (map quote labels) <> "],"
  where
    toLabel = \case
      Pure -> []
      Network -> ["coeffect:network"]
      Auth t -> ["coeffect:auth:" <> t]
      Sandbox t -> ["coeffect:sandbox:" <> t]
      Filesystem t -> ["coeffect:fs:" <> t]

quote :: Text -> Text
quote t = "\"" <> t <> "\""

-- | Load and convert
main :: IO ()
main = do
  args <- getArgs
  case args of
    [] -> do
      hPutStrLn stderr "Usage: dhall-to-buck2 <BUILD.dhall>"
      exitFailure
    (path:_) -> do
      -- For now, just show what we'd emit
      -- TODO: proper Dhall decoding
      putStrLn "# Generated by dhall-to-buck2"
      putStrLn "# Source: BUILD.dhall"
      putStrLn ""
      putStrLn "load(\"@prelude//cxx:cxx.bzl\", \"cxx_binary\", \"cxx_library\")"
      putStrLn ""
      
      -- Read the Dhall file and extract what we can
      content <- TIO.readFile path
      
      -- Quick hack: extract name from the Dhall
      let nameMatch = T.breakOn "name = \"" content
      case nameMatch of
        (_, rest) | not (T.null rest) -> do
          let afterName = T.drop 8 rest  -- drop 'name = "'
              name = T.takeWhile (/= '"') afterName
          
          -- Extract srcs
          let srcsMatch = T.breakOn "srcs = [" content
          srcs <- case srcsMatch of
            (_, rest') | not (T.null rest') -> do
              let afterSrcs = T.drop 8 rest'
                  srcList = T.takeWhile (/= ']') afterSrcs
                  files = filter (not . T.null) $ map (T.strip . T.filter (/= '"')) $ T.splitOn "," srcList
              pure files
            _ -> pure []
          
          -- Emit Buck2 target
          putStrLn $ "cxx_binary("
          putStrLn $ "    name = \"" <> T.unpack name <> "\","
          putStrLn $ "    srcs = [" <> intercalate ", " (map (\s -> "\"" <> T.unpack s <> "\"") srcs) <> "],"
          putStrLn $ ")"
        
        _ -> hPutStrLn stderr "Could not parse BUILD.dhall"
