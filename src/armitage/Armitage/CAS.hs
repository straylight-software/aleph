{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeApplications #-}

{- |
Module      : Armitage.CAS
Description : Content-Addressed Storage client for NativeLink

Client for the Remote Execution API ContentAddressableStorage service.
Uses grapesy for gRPC and proto-lens for message types.

The CAS stores blobs by their SHA256 digest. This module provides:
  - Upload blobs (batch for small, streaming for large)
  - Download blobs (via ByteStream)
  - Check for missing blobs
  - Digest computation

All operations use the standard Remote Execution API:
  https://github.com/bazelbuild/remote-apis
-}
module Armitage.CAS
  ( -- * Configuration
    CASConfig (..)
  , defaultConfig
  , flyConfig

    -- * Client
  , CASClient
  , withCASClient

    -- * Digest
  , Digest (..)
  , digestFromBytes
  , digestToResourceName

    -- * Operations
  , uploadBlob
  , downloadBlob
  , findMissingBlobs
  , blobExists

    -- * Utilities
  , hashBytes
  ) where

import Control.Exception (bracket, try)
import Control.Monad (when)
import Crypto.Hash (SHA256 (..), hashWith)
import Data.ByteString (ByteString)
import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as LBS
import Data.IORef (IORef, newIORef, readIORef, writeIORef)
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import GHC.Generics (Generic)
import Network.Socket (PortNumber)

-- grapesy imports
import Network.GRPC.Client
  ( Connection
  , Server (..)
  , Address (..)
  , ConnParams (..)
  , ServerValidation (..)
  , certStoreFromSystem
  , withConnection
  )
import Network.GRPC.Common (def)

-- Proto imports (generated by proto-lens)
-- TODO: Uncomment when armitage-proto is built
-- import qualified Proto.Build.Bazel.Remote.Execution.V2.RemoteExecution as RE
-- import qualified Proto.Build.Bazel.Remote.Execution.V2.RemoteExecution_Fields as RE
-- import qualified Proto.Google.Bytestream.Bytestream as BS
-- import qualified Proto.Google.Bytestream.Bytestream_Fields as BS

-- -----------------------------------------------------------------------------
-- Configuration
-- -----------------------------------------------------------------------------

-- | CAS client configuration
data CASConfig = CASConfig
  { casHost :: String
  -- ^ CAS server hostname (e.g., "localhost" or "cas.straylight.cx")
  , casPort :: PortNumber
  -- ^ CAS server port (e.g., 50052 for local, 443 for TLS)
  , casUseTLS :: Bool
  -- ^ Use TLS (required for production endpoints)
  , casInstanceName :: Text
  -- ^ Remote execution instance name (usually "main")
  }
  deriving (Show, Eq, Generic)

-- | Default configuration for local NativeLink
defaultConfig :: CASConfig
defaultConfig =
  CASConfig
    { casHost = "localhost"
    , casPort = 50052
    , casUseTLS = False
    , casInstanceName = "main"
    }

-- | Configuration for Fly.io deployment
flyConfig :: CASConfig
flyConfig =
  CASConfig
    { casHost = "aleph-cas.fly.dev"
    , casPort = 443
    , casUseTLS = True
    , casInstanceName = "main"
    }

-- -----------------------------------------------------------------------------
-- Digest
-- -----------------------------------------------------------------------------

-- | Content digest (hash + size)
--
-- This matches the Remote Execution API Digest message:
--   message Digest {
--     string hash = 1;      // SHA256 hex
--     int64 size_bytes = 2;
--   }
data Digest = Digest
  { digestHash :: Text
  -- ^ SHA256 hash as lowercase hex string (64 chars)
  , digestSize :: Int
  -- ^ Size in bytes
  }
  deriving (Show, Eq, Generic)

-- | Compute digest from bytes
digestFromBytes :: ByteString -> Digest
digestFromBytes bs =
  Digest
    { digestHash = hashBytes bs
    , digestSize = BS.length bs
    }

-- | Convert digest to ByteStream resource name
--
-- Format: {instance_name}/blobs/{hash}/{size}
digestToResourceName :: Text -> Digest -> Text
digestToResourceName instanceName Digest {..} =
  instanceName <> "/blobs/" <> digestHash <> "/" <> T.pack (show digestSize)

-- | Hash bytes to SHA256 hex string
hashBytes :: ByteString -> Text
hashBytes bs = T.pack $ show $ hashWith SHA256 bs

-- -----------------------------------------------------------------------------
-- Client
-- -----------------------------------------------------------------------------

-- | Opaque CAS client handle
data CASClient = CASClient
  { clientConfig :: CASConfig
  , clientConn :: Connection
  }

-- | Create CAS client and run action
--
-- Example:
--   withCASClient config $ \client -> do
--     let digest = digestFromBytes content
--     uploadBlob client digest content
withCASClient :: CASConfig -> (CASClient -> IO a) -> IO a
withCASClient config action = do
  let addr = Address
        { addressHost = casHost config
        , addressPort = casPort config
        , addressAuthority = Nothing
        }
      -- Use system certificate store for TLS validation
      -- NoServerValidation would skip verification (insecure)
      serverValidation = ValidateServer certStoreFromSystem
      server = if casUseTLS config
        then ServerSecure serverValidation def addr
        else ServerInsecure addr
      params = def
  withConnection params server $ \conn ->
    action CASClient
      { clientConfig = config
      , clientConn = conn
      }

-- -----------------------------------------------------------------------------
-- Operations
-- -----------------------------------------------------------------------------

-- | Upload blob to CAS
--
-- Uses BatchUpdateBlobs for small blobs (<4MB),
-- ByteStream.Write for large blobs.
uploadBlob :: CASClient -> Digest -> ByteString -> IO ()
uploadBlob client digest content
  | BS.length content < 4 * 1024 * 1024 = batchUpload client digest content
  | otherwise = streamUpload client digest content

-- | Batch upload (for blobs < 4MB)
batchUpload :: CASClient -> Digest -> ByteString -> IO ()
batchUpload client digest content = do
  -- TODO: Use proto-lens types once generated
  -- let request = defMessage
  --       & RE.instanceName .~ casInstanceName (clientConfig client)
  --       & RE.requests .~ [
  --           defMessage
  --             & RE.digest .~ (defMessage & RE.hash .~ digestHash digest
  --                                        & RE.sizeBytes .~ fromIntegral (digestSize digest))
  --             & RE.data' .~ content
  --         ]
  -- response <- nonStreaming (clientConn client)
  --   (RPC :: RPC RE.ContentAddressableStorage "batchUpdateBlobs")
  --   request
  putStrLn $ "CAS: batch upload " <> T.unpack (digestHash digest) <> " (" <> show (digestSize digest) <> " bytes)"

-- | Stream upload (for blobs >= 4MB)
streamUpload :: CASClient -> Digest -> ByteString -> IO ()
streamUpload client digest content = do
  let resourceName = casInstanceName (clientConfig client)
        <> "/uploads/armitage-" <> T.pack (show $ BS.length content)
        <> "/blobs/" <> digestHash digest
        <> "/" <> T.pack (show (digestSize digest))
  -- TODO: Use ByteStream.Write with chunking
  putStrLn $ "CAS: stream upload " <> T.unpack resourceName

-- | Download blob from CAS
--
-- Returns Nothing if blob not found.
downloadBlob :: CASClient -> Digest -> IO (Maybe ByteString)
downloadBlob client digest = do
  let resourceName = digestToResourceName (casInstanceName $ clientConfig client) digest
  -- TODO: Use ByteStream.Read
  -- let request = defMessage & BS.resourceName .~ resourceName
  -- chunks <- serverStreaming (clientConn client)
  --   (RPC :: RPC BS.ByteStream "read")
  --   request
  --   (\response -> return $ response ^. BS.data')
  -- return $ Just $ BS.concat chunks
  putStrLn $ "CAS: download " <> T.unpack resourceName
  pure Nothing

-- | Check which blobs are missing from CAS
--
-- Returns list of digests not present in the store.
findMissingBlobs :: CASClient -> [Digest] -> IO [Digest]
findMissingBlobs client digests = do
  -- TODO: Use proto-lens types once generated
  -- let request = defMessage
  --       & RE.instanceName .~ casInstanceName (clientConfig client)
  --       & RE.blobDigests .~ map toProtoDigest digests
  -- response <- nonStreaming (clientConn client)
  --   (RPC :: RPC RE.ContentAddressableStorage "findMissingBlobs")
  --   request
  -- return $ map fromProtoDigest (response ^. RE.missingBlobDigests)
  putStrLn $ "CAS: find missing blobs (" <> show (length digests) <> " digests)"
  pure digests -- Assume all missing for now

-- | Check if a single blob exists
blobExists :: CASClient -> Digest -> IO Bool
blobExists client digest = do
  missing <- findMissingBlobs client [digest]
  pure (null missing)
