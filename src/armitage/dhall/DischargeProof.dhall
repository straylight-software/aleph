{- DischargeProof.dhall

   Evidence that coeffects were satisfied during a build.
   
   This type mirrors:
   - Haskell: Armitage.Builder.DischargeProof
   - Lean: Continuity.DischargeProof (when formalized)
   
   The proof is:
   1. Generated by armitage after successful build
   2. Signed (optionally) with ed25519
   3. Verifiable by the Lean formalization
   
   Soundness: A valid DischargeProof for coeffects C implies that
   the build environment actually provided C during execution.
-}

let Resource = ./Resource.dhall

--------------------------------------------------------------------------------
-- Network Access Witness
--
-- Recorded by the TLS MITM proxy. Each access includes the content hash,
-- so replays can verify the same content was received.
--------------------------------------------------------------------------------

let NetworkAccess
    : Type
    = { url : Text
      , method : Text               -- GET, POST, etc.
      , contentHash : Text          -- SHA256 of response body
      , timestamp : Text            -- ISO 8601
      }

--------------------------------------------------------------------------------
-- Filesystem Access Witness
--
-- Recorded for non-pure builds that access paths outside the sandbox.
--------------------------------------------------------------------------------

let FilesystemAccess
    : Type
    = { path : Text
      , mode : < Read | Write | Execute >
      , contentHash : Optional Text  -- SHA256 if readable file
      , timestamp : Text
      }

--------------------------------------------------------------------------------
-- Auth Token Usage
--
-- Recorded when a build uses an authentication token.
-- The token value itself is NOT recorded (security), just the provider.
--------------------------------------------------------------------------------

let AuthUsage
    : Type
    = { provider : Text             -- e.g., "github", "docker"
      , scope : Optional Text       -- what scope was used
      , timestamp : Text
      }

--------------------------------------------------------------------------------
-- Discharge Proof
--
-- Complete evidence of coeffect satisfaction.
--------------------------------------------------------------------------------

let DischargeProof
    : Type
    = { -- What coeffects were required
        coeffects : Resource.Resources
        
        -- Evidence of network access (from witness proxy)
      , networkAccess : List NetworkAccess
        
        -- Evidence of filesystem access (from sandbox hooks)
      , filesystemAccess : List FilesystemAccess
        
        -- Evidence of auth token usage
      , authUsage : List AuthUsage
        
        -- Build metadata
      , buildId : Text              -- unique build identifier
      , derivationHash : Text       -- content hash of input derivation
      , outputHashes : List { name : Text, hash : Text }
      , startTime : Text            -- ISO 8601
      , endTime : Text              -- ISO 8601
        
        -- Optional cryptographic signature
        -- Signs: sha256(derivationHash ++ outputHashes ++ evidence)
      , signature : Optional { publicKey : Text, sig : Text }
      }

--------------------------------------------------------------------------------
-- Constructors
--------------------------------------------------------------------------------

-- Empty proof for pure builds (no external requirements)
let pureProof
    : { buildId : Text
      , derivationHash : Text
      , outputHashes : List { name : Text, hash : Text }
      , startTime : Text
      , endTime : Text
      } → DischargeProof
    = λ(meta : { buildId : Text
               , derivationHash : Text
               , outputHashes : List { name : Text, hash : Text }
               , startTime : Text
               , endTime : Text
               }) →
        { coeffects = Resource.pure
        , networkAccess = [] : List NetworkAccess
        , filesystemAccess = [] : List FilesystemAccess
        , authUsage = [] : List AuthUsage
        , buildId = meta.buildId
        , derivationHash = meta.derivationHash
        , outputHashes = meta.outputHashes
        , startTime = meta.startTime
        , endTime = meta.endTime
        , signature = None { publicKey : Text, sig : Text }
        }

--------------------------------------------------------------------------------
-- Verification predicates
--
-- These would ideally be in Lean, but we express the structure here
-- so Dhall can validate the shape at parse time.
--------------------------------------------------------------------------------

-- Check if proof is for pure build
let isPure : DischargeProof → Bool = λ(p : DischargeProof) →
    Resource.isPure p.coeffects

-- Check if proof has network evidence
let hasNetworkEvidence : DischargeProof → Bool = λ(p : DischargeProof) →
    merge
      { None = False
      , Some = λ(_ : NetworkAccess) → True
      }
      (List/head NetworkAccess p.networkAccess)

-- Check if proof is signed
let isSigned : DischargeProof → Bool = λ(p : DischargeProof) →
    merge
      { None = False
      , Some = λ(_ : { publicKey : Text, sig : Text }) → True
      }
      p.signature

in  { -- Types
      NetworkAccess
    , FilesystemAccess
    , AuthUsage
    , DischargeProof
      -- Constructors
    , pureProof
      -- Predicates
    , isPure
    , hasNetworkEvidence
    , isSigned
    }
