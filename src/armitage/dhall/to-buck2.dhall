{- to-buck2.dhall

   Render a Dhall Target as a Buck2 BUCK file.
   
   This version uses nix_genrule.bzl which resolves nix flake refs at
   genrule execution time (not analysis time). This avoids the need for
   .buckconfig.local shell hook magic.
   
   Usage:
     dhall text <<< '(./to-buck2.dhall).render ./BUILD.dhall'
     dhall text <<< '(./to-buck2.dhall).render ./BUILD.dhall' > BUCK
-}

let Target = ./Build.dhall
let Resource = ./Resource.dhall
let Prelude = https://prelude.dhall-lang.org/v23.1.0/package.dhall
  sha256:931cbfae9d746c4611b07633ab1e547637ab4ba138b16bf65ef1b9ad66a60b7f

-- Quote a string for Starlark
let quote = \(t : Text) -> "\"${t}\""

-- Join list of text with separator
let join : Text -> List Text -> Text = \(sep : Text) -> \(xs : List Text) ->
  Prelude.Text.concatSep sep xs

-- Render sources list (only handles Files variant for now)
let renderSrcs : Target.Src -> Text = \(srcs : Target.Src) ->
  merge
    { Files = \(files : List Text) -> 
        let quoted = Prelude.List.map Text Text quote files
        in "[" ++ join ", " quoted ++ "]"
    , Fetch = \(_ : { url : Text, hash : Text }) -> "[]"
    , Git = \(_ : { url : Text, rev : Text, hash : Text }) -> "[]"
    }
    srcs

-- Extract flake refs from deps (these become nix_deps)
let extractFlakeRefs : List Target.Dep -> List Text = \(deps : List Target.Dep) ->
  Prelude.List.concatMap
    Target.Dep
    Text
    (\(d : Target.Dep) -> 
      merge
        { Local = \(_ : Text) -> [] : List Text
        , Flake = \(ref : Text) -> [ref]
        , PkgConfig = \(_ : Text) -> [] : List Text
        , External = \(_ : { hash : Text, name : Text }) -> [] : List Text
        }
        d
    )
    deps

-- Render list of text as Starlark list
let renderList : List Text -> Text = \(xs : List Text) ->
  let quoted = Prelude.List.map Text Text quote xs
  in "[" ++ join ", " quoted ++ "]"

-- Extract local deps (become regular deps in Buck2)
let extractLocalDeps : List Target.Dep -> List Text = \(deps : List Target.Dep) ->
  Prelude.List.concatMap
    Target.Dep
    Text
    (\(d : Target.Dep) -> 
      merge
        { Local = \(t : Text) -> [t]
        , Flake = \(_ : Text) -> [] : List Text
        , PkgConfig = \(_ : Text) -> [] : List Text
        , External = \(_ : { hash : Text, name : Text }) -> [] : List Text
        }
        d
    )
    deps

-- Render coeffects as string
let renderCoeffects : Resource.Resources -> Text = \(rs : Resource.Resources) ->
  if Resource.isPure rs then "pure"
  else 
    let first = List/head Resource.Resource rs
    in merge
         { None = "pure"
         , Some = Resource.renderOne
         }
         first

-- Get compiler from toolchain
let getCompiler : Target.Toolchain.Toolchain -> Text = 
  \(tc : Target.Toolchain.Toolchain) ->
    merge
      { Clang = \(_ : { version : Text }) -> "clang++"
      , NVClang = \(_ : { version : Text }) -> "nv-clang++"
      , GCC = \(_ : { version : Text }) -> "g++"
      , NVCC = \(_ : { version : Text }) -> "nvcc"
      , Rustc = \(_ : { version : Text }) -> "rustc"
      , GHC = \(_ : { version : Text }) -> "ghc"
      , Lean = \(_ : { version : Text }) -> "lean"
      }
      tc.compiler

-- Main render function  
let render : Target.Target -> Text = \(target : Target.Target) ->
  let flakeRefs = extractFlakeRefs target.deps
  let coeffects = renderCoeffects target.requires
  let compiler = getCompiler target.toolchain
  in
  ''
  # Generated by dhall-to-buck2
  # Target: ${target.name}
  # Coeffects: ${coeffects}

  load("@toolchains//:nix_genrule.bzl", "nix_cxx_binary")

  nix_cxx_binary(
      name = ${quote target.name},
      srcs = ${renderSrcs target.srcs},
      nix_deps = ${renderList flakeRefs},
      compiler = "${compiler}",
  )
  ''

-- Render with witnessed execution (attestations)
let renderWitnessed : Target.Target -> Text = \(target : Target.Target) ->
  let flakeRefs = extractFlakeRefs target.deps
  let coeffects = renderCoeffects target.requires
  let compiler = getCompiler target.toolchain
  in
  ''
  # Generated by dhall-to-buck2 (witnessed)
  # Target: ${target.name}
  # Coeffects: ${coeffects}

  load("@toolchains//:nix_genrule.bzl", "nix_cxx_binary_witnessed")

  nix_cxx_binary_witnessed(
      name = ${quote target.name},
      srcs = ${renderSrcs target.srcs},
      nix_deps = ${renderList flakeRefs},
      compiler = "${compiler}",
      coeffects = "${coeffects}",
  )
  ''

in  { render
    , renderWitnessed
    , default = render
    }
