# toolchains/lean.bzl
#
# Hermetic Lean 4 toolchain using Nix store paths.
#
# Lean 4 is a functional programming language and theorem prover.
# Paths are read from .buckconfig.local [lean] section, generated by `nix develop`.

LeanToolchainInfo = provider(
    fields = {
        "lean": provider_field(str),
        "leanc": provider_field(str),
        "lake": provider_field(str),
        "lean_lib_dir": provider_field(str),
        "lean_include_dir": provider_field(str),
    },
)

def _lean_toolchain_impl(ctx: AnalysisContext) -> list[Provider]:
    """
    Lean 4 toolchain with paths from .buckconfig.local.

    Reads [lean] section for absolute Nix store paths:
      lean           - Lean interpreter/compiler
      leanc          - Lean C code generator
      lake           - Lean package manager
      lean_lib_dir   - Lean library directory
      lean_include_dir - Lean include directory
    """

    # Read tool paths from config
    lean = read_root_config("lean", "lean", ctx.attrs.lean)
    leanc = read_root_config("lean", "leanc", ctx.attrs.leanc)
    lake = read_root_config("lean", "lake", ctx.attrs.lake)
    lean_lib_dir = read_root_config("lean", "lean_lib_dir", ctx.attrs.lean_lib_dir)
    lean_include_dir = read_root_config("lean", "lean_include_dir", ctx.attrs.lean_include_dir)

    return [
        DefaultInfo(),
        LeanToolchainInfo(
            lean = lean,
            leanc = leanc,
            lake = lake,
            lean_lib_dir = lean_lib_dir,
            lean_include_dir = lean_include_dir,
        ),
    ]

lean_toolchain = rule(
    impl = _lean_toolchain_impl,
    attrs = {
        "lean": attrs.string(default = "lean"),
        "leanc": attrs.string(default = "leanc"),
        "lake": attrs.string(default = "lake"),
        "lean_lib_dir": attrs.string(default = ""),
        "lean_include_dir": attrs.string(default = ""),
    },
    is_toolchain_rule = True,
)

def lean_library(
        name: str,
        srcs: list[str],
        deps: list[str] = [],
        visibility: list[str] = []):
    """
    Build a Lean 4 library.

    Args:
        name: Target name
        srcs: List of .lean source files
        deps: Dependencies (other lean_library targets)
        visibility: Visibility specification
    """
    lean = read_root_config("lean", "lean", "lean")

    # Use genrule for now - proper lean rules would need more infrastructure
    native.genrule(
        name = name,
        srcs = srcs,
        out = name + ".olean",
        cmd = "{lean} --make -o $OUT $SRCS".format(lean = lean),
        visibility = visibility,
    )

def lean_binary(
        name: str,
        srcs: list[str],
        deps: list[str] = [],
        visibility: list[str] = []):
    """
    Build a Lean 4 executable.

    Compiles a Lean source file to a native executable using leanc.
    For multi-file projects, consider using Lake.

    Args:
        name: Target name
        srcs: List of .lean source files (typically one main file)
        deps: Dependencies (other lean_library targets)
        visibility: Visibility specification
    """
    lean = read_root_config("lean", "lean", "lean")
    leanc = read_root_config("lean", "leanc", "leanc")

    # Compile Lean to C, then to native binary
    # Note: Only single-file binaries supported; for multi-file, use Lake
    src_file = srcs[0]
    src_basename = src_file.split("/")[-1] if "/" in src_file else src_file

    native.genrule(
        name = name,
        srcs = srcs,
        out = name,
        bash = """
set -e
# Copy source to scratch (Lean requires source in root dir)
cp "$SRCDIR/{src_basename}" "$BUCK_SCRATCH_PATH/{src_basename}"
# Compile Lean source to C
{lean} --threads=1 --root="$BUCK_SCRATCH_PATH" --c="$BUCK_SCRATCH_PATH/out.c" "$BUCK_SCRATCH_PATH/{src_basename}"
# Compile C to native executable
{leanc} -o "$OUT" "$BUCK_SCRATCH_PATH/out.c"
""".format(lean = lean, leanc = leanc, src_basename = src_basename),
        executable = True,
        visibility = visibility,
    )
