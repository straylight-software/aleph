# toolchains/rust.bzl
#
# Hermetic Rust toolchain and rules using Nix store paths.
#
# Paths are read from .buckconfig.local [rust] section, generated by `nix develop`.
# No PATH lookup. Just absolute Nix store paths.
#
# Rules:
#   rust_toolchain - toolchain definition
#   rust_binary    - executable
#   rust_library   - rlib

# Use prelude types directly - avoids nominal typing mismatch between cells
load("@prelude//rust:rust_toolchain.bzl", "PanicRuntime", "RustToolchainInfo")

# Provider for rust library outputs
RustLibraryInfo = provider(fields = [
    "rlib",        # The .rlib artifact
    "crate_name",  # Crate name for --extern
])

def _rust_toolchain_impl(ctx: AnalysisContext) -> list[Provider]:
    """
    Rust toolchain with paths from .buckconfig.local.

    Reads [rust] section for absolute Nix store paths:
      rustc       - Rust compiler
      rustdoc     - Documentation generator
      clippy      - Linter
      cargo       - Package manager (for build scripts)
    """

    # Read tool paths from config
    rustc = read_root_config("rust", "rustc", "rustc")
    rustdoc = read_root_config("rust", "rustdoc", "rustdoc")
    clippy_driver = read_root_config("rust", "clippy_driver", "clippy-driver")

    # Target triple
    target_triple = read_root_config("rust", "target_triple", "x86_64-unknown-linux-gnu")

    return [
        DefaultInfo(),
        RustToolchainInfo(
            compiler = RunInfo(args = [rustc]),
            rustdoc = RunInfo(args = [rustdoc]),
            clippy_driver = RunInfo(args = [clippy_driver]),
            rustc_target_triple = target_triple,
            default_edition = ctx.attrs.default_edition,
            panic_runtime = PanicRuntime(ctx.attrs.panic_runtime),
            rustc_flags = ctx.attrs.rustc_flags,
            rustc_binary_flags = ctx.attrs.rustc_binary_flags,
            rustc_test_flags = ctx.attrs.rustc_test_flags,
            rustdoc_flags = ctx.attrs.rustdoc_flags,
            allow_lints = ctx.attrs.allow_lints,
            deny_lints = ctx.attrs.deny_lints,
            warn_lints = ctx.attrs.warn_lints,
            report_unused_deps = ctx.attrs.report_unused_deps,
            doctests = ctx.attrs.doctests,
        ),
    ]

rust_toolchain = rule(
    impl = _rust_toolchain_impl,
    attrs = {
        "default_edition": attrs.string(default = "2021"),
        "panic_runtime": attrs.string(default = "unwind"),
        "rustc_flags": attrs.list(attrs.string(), default = []),
        "rustc_binary_flags": attrs.list(attrs.string(), default = []),
        "rustc_test_flags": attrs.list(attrs.string(), default = []),
        "rustdoc_flags": attrs.list(attrs.string(), default = []),
        "allow_lints": attrs.list(attrs.string(), default = []),
        "deny_lints": attrs.list(attrs.string(), default = []),
        "warn_lints": attrs.list(attrs.string(), default = []),
        "report_unused_deps": attrs.bool(default = False),
        "doctests": attrs.bool(default = False),
    },
    is_toolchain_rule = True,
)

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# rust_binary
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

def _rust_binary_impl(ctx: AnalysisContext) -> list[Provider]:
    """
    Build a Rust binary.
    
    Simple: rustc srcs -o output
    """
    rustc = read_root_config("rust", "rustc", "rustc")
    
    out = ctx.actions.declare_output(ctx.attrs.name)
    
    cmd = cmd_args([rustc])
    
    # Edition
    cmd.add("--edition", ctx.attrs.edition)
    
    # Optimization
    cmd.add("-O")
    
    # Output
    cmd.add("-o", out.as_output())
    
    # Collect deps (rlibs)
    for dep in ctx.attrs.deps:
        if RustLibraryInfo in dep:
            lib_info = dep[RustLibraryInfo]
            cmd.add(cmd_args("--extern", cmd_args(lib_info.crate_name, "=", lib_info.rlib, delimiter = "")))
    
    # Sources
    for src in ctx.attrs.srcs:
        cmd.add(src)
    
    ctx.actions.run(cmd, category = "rustc")
    
    return [
        DefaultInfo(default_output = out),
        RunInfo(args = cmd_args(out)),
    ]

rust_binary = rule(
    impl = _rust_binary_impl,
    attrs = {
        "srcs": attrs.list(attrs.source()),
        "deps": attrs.list(attrs.dep(), default = []),
        "edition": attrs.string(default = "2021"),
    },
)

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# rust_library
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

def _rust_library_impl(ctx: AnalysisContext) -> list[Provider]:
    """
    Build a Rust library (rlib).
    """
    rustc = read_root_config("rust", "rustc", "rustc")
    
    crate_name = ctx.attrs.crate_name or ctx.attrs.name
    out = ctx.actions.declare_output("lib{}.rlib".format(crate_name))
    
    cmd = cmd_args([rustc])
    
    # Build rlib
    cmd.add("--crate-type", "rlib")
    cmd.add("--crate-name", crate_name)
    
    # Edition
    cmd.add("--edition", ctx.attrs.edition)
    
    # Optimization
    cmd.add("-O")
    
    # Output
    cmd.add("-o", out.as_output())
    
    # Collect deps
    for dep in ctx.attrs.deps:
        if RustLibraryInfo in dep:
            lib_info = dep[RustLibraryInfo]
            cmd.add(cmd_args("--extern", cmd_args(lib_info.crate_name, "=", lib_info.rlib, delimiter = "")))
    
    # Sources
    for src in ctx.attrs.srcs:
        cmd.add(src)
    
    ctx.actions.run(cmd, category = "rustc")
    
    return [
        DefaultInfo(default_output = out),
        RustLibraryInfo(rlib = out, crate_name = crate_name),
    ]

rust_library = rule(
    impl = _rust_library_impl,
    attrs = {
        "srcs": attrs.list(attrs.source()),
        "deps": attrs.list(attrs.dep(), default = []),
        "edition": attrs.string(default = "2021"),
        "crate_name": attrs.option(attrs.string(), default = None),
    },
)
