# toolchains/rust.bzl
#
# Hermetic Rust toolchain and rules using Nix store paths.
#
# Paths are read from .buckconfig.local [rust] section, generated by `nix develop`.
# No PATH lookup. Just absolute Nix store paths.
#
# Rules:
#   rust_toolchain - toolchain definition
#   rust_binary    - executable
#   rust_library   - rlib

# NOTE: Use upstream @prelude types for toolchain provider compatibility.
# Our custom rust_binary/rust_library rules below don't use the toolchain
# provider - they read config directly. But if anyone uses prelude rust rules,
# they'll need the upstream provider type.
load("@prelude//rust:rust_toolchain.bzl", "PanicRuntime", "RustToolchainInfo")

# Import RustCrateInfo so we can handle deps from crates_io()
load("@toolchains//rust_crate.bzl", "RustCrateInfo")

# Provider for rust library outputs
RustLibraryInfo = provider(fields = [
    "rlib",           # The .rlib artifact
    "crate_name",     # Crate name for --extern
    "transitive_deps", # List of all transitive rlib artifacts (for -L paths)
])

def _rust_toolchain_impl(ctx: AnalysisContext) -> list[Provider]:
    """
    Rust toolchain with paths from .buckconfig.local.

    Reads [rust] section for absolute Nix store paths:
      rustc       - Rust compiler
      rustdoc     - Documentation generator
      clippy      - Linter
      cargo       - Package manager (for build scripts)
    """

    # Read tool paths from config
    rustc = read_root_config("rust", "rustc", "rustc")
    rustdoc = read_root_config("rust", "rustdoc", "rustdoc")
    clippy_driver = read_root_config("rust", "clippy_driver", "clippy-driver")

    # Target triple
    target_triple = read_root_config("rust", "target_triple", "x86_64-unknown-linux-gnu")

    return [
        DefaultInfo(),
        RustToolchainInfo(
            compiler = RunInfo(args = [rustc]),
            rustdoc = RunInfo(args = [rustdoc]),
            clippy_driver = RunInfo(args = [clippy_driver]),
            rustc_target_triple = target_triple,
            default_edition = ctx.attrs.default_edition,
            panic_runtime = PanicRuntime(ctx.attrs.panic_runtime),
            rustc_flags = ctx.attrs.rustc_flags,
            rustc_binary_flags = ctx.attrs.rustc_binary_flags,
            rustc_test_flags = ctx.attrs.rustc_test_flags,
            rustdoc_flags = ctx.attrs.rustdoc_flags,
            allow_lints = ctx.attrs.allow_lints,
            deny_lints = ctx.attrs.deny_lints,
            warn_lints = ctx.attrs.warn_lints,
            report_unused_deps = ctx.attrs.report_unused_deps,
            doctests = ctx.attrs.doctests,
        ),
    ]

rust_toolchain = rule(
    impl = _rust_toolchain_impl,
    attrs = {
        "default_edition": attrs.string(default = "2021"),
        "panic_runtime": attrs.string(default = "unwind"),
        "rustc_flags": attrs.list(attrs.string(), default = []),
        "rustc_binary_flags": attrs.list(attrs.string(), default = []),
        "rustc_test_flags": attrs.list(attrs.string(), default = []),
        "rustdoc_flags": attrs.list(attrs.string(), default = []),
        "allow_lints": attrs.list(attrs.string(), default = []),
        "deny_lints": attrs.list(attrs.string(), default = []),
        "warn_lints": attrs.list(attrs.string(), default = []),
        "report_unused_deps": attrs.bool(default = False),
        "doctests": attrs.bool(default = False),
    },
    is_toolchain_rule = True,
)

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# rust_binary
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

def _rust_binary_impl(ctx: AnalysisContext) -> list[Provider]:
    """
    Build a Rust binary.
    
    Simple: rustc srcs -o output
    """
    rustc = read_root_config("rust", "rustc", "rustc")
    
    out = ctx.actions.declare_output(ctx.attrs.name)
    
    cmd = cmd_args([rustc])
    
    # Edition
    cmd.add("--edition", ctx.attrs.edition)
    
    # Optimization
    cmd.add("-O")
    
    # Output
    cmd.add("-o", out.as_output())
    
    # Collect deps (rlibs) - handle both RustLibraryInfo and RustCrateInfo
    for dep in ctx.attrs.deps:
        if RustLibraryInfo in dep:
            lib_info = dep[RustLibraryInfo]
            cmd.add(cmd_args("--extern", cmd_args(lib_info.crate_name, "=", lib_info.rlib, delimiter = "")))
            # Add search path for RustLibraryInfo deps too
            cmd.add(cmd_args(lib_info.rlib, format = "-Ldependency={}", parent = 1))
            # Add search paths for all transitive deps
            for trans_rlib in lib_info.transitive_deps:
                cmd.add(cmd_args(trans_rlib, format = "-Ldependency={}", parent = 1))
        elif RustCrateInfo in dep:
            crate_info = dep[RustCrateInfo]
            cmd.add(cmd_args("--extern", cmd_args(crate_info.crate_name, "=", crate_info.rlib, delimiter = "")))
            # Add search path for this dep
            cmd.add(cmd_args(crate_info.rlib, format = "-Ldependency={}", parent = 1))
            # Add search paths for all transitive deps
            for trans_rlib in crate_info.transitive_deps:
                cmd.add(cmd_args(trans_rlib, format = "-Ldependency={}", parent = 1))
    
    # Binary root is the first source file
    # Other sources are included as hidden deps so they're tracked for rebuilds
    if ctx.attrs.srcs:
        cmd.add(ctx.attrs.srcs[0])
        if len(ctx.attrs.srcs) > 1:
            cmd.add(cmd_args(hidden = ctx.attrs.srcs[1:]))
    
    ctx.actions.run(cmd, category = "rustc")
    
    return [
        DefaultInfo(default_output = out),
        RunInfo(args = cmd_args(out)),
    ]

rust_binary = rule(
    impl = _rust_binary_impl,
    attrs = {
        "srcs": attrs.list(attrs.source()),
        "deps": attrs.list(attrs.dep(), default = []),
        "edition": attrs.string(default = "2021"),
    },
)

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# rust_library
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

def _rust_library_impl(ctx: AnalysisContext) -> list[Provider]:
    """
    Build a Rust library (rlib or proc-macro).
    
    The first source file is treated as the crate root (lib.rs).
    Other sources are tracked as dependencies but not passed directly to rustc.
    """
    rustc = read_root_config("rust", "rustc", "rustc")
    
    crate_name = ctx.attrs.crate_name or ctx.attrs.name
    
    # Determine crate type and output extension
    if ctx.attrs.proc_macro:
        out = ctx.actions.declare_output("lib{}.so".format(crate_name))
        crate_type = "proc-macro"
    else:
        out = ctx.actions.declare_output("lib{}.rlib".format(crate_name))
        crate_type = "rlib"
    
    cmd = cmd_args([rustc])
    
    # Build crate
    cmd.add("--crate-type", crate_type)
    cmd.add("--crate-name", crate_name)
    
    # Edition
    cmd.add("--edition", ctx.attrs.edition)
    
    # Optimization
    cmd.add("-O")
    
    # Output
    cmd.add("-o", out.as_output())
    
    # Proc-macro crates need access to the proc_macro crate from sysroot
    if ctx.attrs.proc_macro:
        cmd.add("--extern", "proc_macro")
    
    # Features
    for feature in ctx.attrs.features:
        cmd.add("--cfg", 'feature="{}"'.format(feature))
    
    # Collect transitive deps for propagation
    transitive_deps = []
    
    # Collect deps - handle both RustLibraryInfo and RustCrateInfo
    for dep in ctx.attrs.deps:
        if RustLibraryInfo in dep:
            lib_info = dep[RustLibraryInfo]
            cmd.add(cmd_args("--extern", cmd_args(lib_info.crate_name, "=", lib_info.rlib, delimiter = "")))
            # Add search path for RustLibraryInfo deps too
            cmd.add(cmd_args(lib_info.rlib, format = "-Ldependency={}", parent = 1))
            # Collect this dep's rlib for transitive propagation
            transitive_deps.append(lib_info.rlib)
            # Also add all of its transitive deps
            for trans_rlib in lib_info.transitive_deps:
                cmd.add(cmd_args(trans_rlib, format = "-Ldependency={}", parent = 1))
                transitive_deps.append(trans_rlib)
        elif RustCrateInfo in dep:
            crate_info = dep[RustCrateInfo]
            cmd.add(cmd_args("--extern", cmd_args(crate_info.crate_name, "=", crate_info.rlib, delimiter = "")))
            # Add search path for this dep
            cmd.add(cmd_args(crate_info.rlib, format = "-Ldependency={}", parent = 1))
            # Collect this dep's rlib for transitive propagation
            transitive_deps.append(crate_info.rlib)
            # Add search paths for all transitive deps
            for trans_rlib in crate_info.transitive_deps:
                cmd.add(cmd_args(trans_rlib, format = "-Ldependency={}", parent = 1))
                transitive_deps.append(trans_rlib)
    
    # Crate root is the first source file
    # Other sources are included as hidden deps so they're tracked for rebuilds
    if ctx.attrs.srcs:
        cmd.add(ctx.attrs.srcs[0])
        if len(ctx.attrs.srcs) > 1:
            cmd.add(cmd_args(hidden = ctx.attrs.srcs[1:]))
    
    ctx.actions.run(cmd, category = "rustc")
    
    return [
        DefaultInfo(default_output = out),
        RustLibraryInfo(rlib = out, crate_name = crate_name, transitive_deps = transitive_deps),
    ]

rust_library = rule(
    impl = _rust_library_impl,
    attrs = {
        "srcs": attrs.list(attrs.source()),
        "deps": attrs.list(attrs.dep(), default = []),
        "edition": attrs.string(default = "2021"),
        "crate_name": attrs.option(attrs.string(), default = None),
        "proc_macro": attrs.bool(default = False),
        "features": attrs.list(attrs.string(), default = []),
    },
)
