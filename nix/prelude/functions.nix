# nix/prelude/functions.nix
#
# Standalone prelude functions for nixdoc generation.
# This file mirrors the functional core from overlays/prelude.nix
# but in a format that nixdoc can parse (top-level rec block).
#
# DO NOT edit this file directly for function implementations.
# Edit overlays/prelude.nix and ensure this file stays in sync.
#
# This file exists solely for documentation generation.

{ lib }:

rec {
  # ═══════════════════════════════════════════════════════════════════════════
  # Fundamentals
  # ═══════════════════════════════════════════════════════════════════════════

  /**
    The identity function. Returns its argument unchanged.

    Useful as a default function argument or in higher-order contexts
    where a "do nothing" transformation is needed.

    # Type

    ```
    id :: a -> a
    ```

    # Arguments

    x
    : any value

    # Examples

    :::{.example}
    ## `prelude.id` usage example

    ```nix
    id 42
    => 42

    id "hello"
    => "hello"

    map id [ 1 2 3 ]
    => [ 1 2 3 ]
    ```

    :::
  */
  id = x: x;

  /**
    Create a constant function that always returns the first argument.

    Takes two arguments and returns the first, ignoring the second.
    Useful for creating functions that ignore their input.

    # Type

    ```
    const :: a -> b -> a
    ```

    # Arguments

    a
    : the value to always return

    b
    : ignored argument

    # Examples

    :::{.example}
    ## `prelude.const` usage example

    ```nix
    const 42 "ignored"
    => 42

    map (const 0) [ "a" "b" "c" ]
    => [ 0 0 0 ]

    const "default" null
    => "default"
    ```

    :::
  */
  const = a: _b: a;

  /**
    Flip the order of arguments to a binary function.

    Takes a function of two arguments and returns a new function
    with the argument order reversed.

    # Type

    ```
    flip :: (a -> b -> c) -> b -> a -> c
    ```

    # Arguments

    f
    : binary function to flip

    a
    : becomes the second argument to f

    b
    : becomes the first argument to f

    # Examples

    :::{.example}
    ## `prelude.flip` usage example

    ```nix
    flip builtins.sub 3 10
    => 7

    flip const "first" "second"
    => "second"

    (flip map [ 1 2 3 ]) (x: x * 2)
    => [ 2 4 6 ]
    ```

    :::
  */
  flip =
    f: a: b:
    f b a;

  /**
    Compose two functions (right to left).

    Creates a new function that applies g first, then f to the result.
    Mathematical notation: (f . g)(x) = f(g(x))

    # Type

    ```
    compose :: (b -> c) -> (a -> b) -> a -> c
    ```

    # Arguments

    f
    : outer function to apply second

    g
    : inner function to apply first

    x
    : input value

    # Examples

    :::{.example}
    ## `prelude.compose` usage example

    ```nix
    compose (x: x + 1) (x: x * 2) 5
    => 11

    compose toString (x: x * x) 4
    => "16"

    (compose head tail) [ 1 2 3 ]
    => 2
    ```

    :::
  */
  compose =
    f: g: x:
    f (g x);

  /**
    Compose two functions (left to right).

    Creates a new function that applies f first, then g to the result.
    Also known as forward composition or "then".

    # Type

    ```
    pipe :: (a -> b) -> (b -> c) -> a -> c
    ```

    # Arguments

    f
    : first function to apply

    g
    : second function to apply

    x
    : input value

    # Examples

    :::{.example}
    ## `prelude.pipe` usage example

    ```nix
    pipe (x: x * 2) (x: x + 1) 5
    => 11

    pipe (x: x * x) toString 4
    => "16"

    (pipe tail head) [ 1 2 3 ]
    => 2
    ```

    :::
  */
  pipe =
    f: g: x:
    g (f x);

  /**
    Compute the fixed point of a function.

    Returns a value x such that f(x) = x. Used for defining recursive
    values and creating self-referential data structures.

    # Type

    ```
    fix :: (a -> a) -> a
    ```

    # Arguments

    f
    : function whose fixed point to compute

    # Examples

    :::{.example}
    ## `prelude.fix` usage example

    ```nix
    fix (self: { a = 1; b = self.a + 1; })
    => { a = 1; b = 2; }
    ```

    :::
  */
  fix =
    f:
    let
      x = f x;
    in
    x;

  /**
    Apply a binary function with transformed arguments.

    Applies a unary function to both arguments before passing to binary function.
    Useful for comparing or combining transformed values.

    # Type

    ```
    on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
    ```

    # Arguments

    op
    : binary operation to apply

    f
    : transformation to apply to both arguments

    x
    : first value

    y
    : second value

    # Examples

    :::{.example}
    ## `prelude.on` usage example

    ```nix
    on builtins.lessThan builtins.stringLength "cat" "mouse"
    => true

    on add (x: x * x) 2 3
    => 13
    ```

    :::
  */
  on =
    op: f: x: y:
    op (f x) (f y);

  # ═══════════════════════════════════════════════════════════════════════════
  # Lists - Core
  # ═══════════════════════════════════════════════════════════════════════════

  /**
    Apply a function to each element of a list.

    # Type

    ```
    map :: (a -> b) -> [a] -> [b]
    ```

    # Arguments

    f
    : function to apply

    xs
    : input list

    # Examples

    :::{.example}
    ## `prelude.map` usage example

    ```nix
    map (x: x * 2) [ 1 2 3 ]
    => [ 2 4 6 ]

    map toString [ 1 2 3 ]
    => [ "1" "2" "3" ]
    ```

    :::
  */
  inherit (builtins) map;

  /**
    Keep only elements that satisfy a predicate.

    # Type

    ```
    filter :: (a -> bool) -> [a] -> [a]
    ```

    # Arguments

    pred
    : predicate function

    xs
    : input list

    # Examples

    :::{.example}
    ## `prelude.filter` usage example

    ```nix
    filter (x: x > 2) [ 1 2 3 4 5 ]
    => [ 3 4 5 ]

    filter (x: x != "b") [ "a" "b" "c" ]
    => [ "a" "c" ]
    ```

    :::
  */
  inherit (builtins) filter;

  /**
    Left fold over a list.

    Reduces a list to a single value by applying a binary function
    from left to right, starting with an initial accumulator.

    # Type

    ```
    fold :: (b -> a -> b) -> b -> [a] -> b
    ```

    # Arguments

    f
    : binary function (accumulator -> element -> accumulator)

    init
    : initial accumulator value

    xs
    : list to fold

    # Examples

    :::{.example}
    ## `prelude.fold` usage example

    ```nix
    fold (acc: x: acc + x) 0 [ 1 2 3 4 ]
    => 10

    fold (acc: x: acc ++ [x * 2]) [] [ 1 2 3 ]
    => [ 2 4 6 ]
    ```

    :::
  */
  fold = builtins.foldl';

  /**
    Right fold over a list.

    Reduces a list to a single value by applying a binary function
    from right to left, starting with an initial accumulator.

    # Type

    ```
    fold-right :: (a -> b -> b) -> b -> [a] -> b
    ```

    # Arguments

    f
    : binary function (element -> accumulator -> accumulator)

    init
    : initial accumulator value

    xs
    : list to fold

    # Examples

    :::{.example}
    ## `prelude.fold-right` usage example

    ```nix
    fold-right (x: acc: [ x ] ++ acc) [] [ 1 2 3 ]
    => [ 1 2 3 ]

    fold-right (x: acc: "(${toString x} ${acc})") "end" [ 1 2 3 ]
    => "(1 (2 (3 end)))"
    ```

    :::
  */
  fold-right = lib.foldr;

  /**
    Get the first element of a list.

    # Type

    ```
    head :: [a] -> a
    ```

    # Arguments

    xs
    : non-empty list

    # Examples

    :::{.example}
    ## `prelude.head` usage example

    ```nix
    head [ 1 2 3 ]
    => 1

    head [ "only" ]
    => "only"
    ```

    :::
  */
  inherit (builtins) head;

  /**
    Get all elements except the first.

    # Type

    ```
    tail :: [a] -> [a]
    ```

    # Arguments

    xs
    : non-empty list

    # Examples

    :::{.example}
    ## `prelude.tail` usage example

    ```nix
    tail [ 1 2 3 ]
    => [ 2 3 ]

    tail [ "only" ]
    => [ ]
    ```

    :::
  */
  inherit (builtins) tail;

  /**
    Get all elements except the last.

    # Type

    ```
    init :: [a] -> [a]
    ```

    # Arguments

    xs
    : non-empty list

    # Examples

    :::{.example}
    ## `prelude.init` usage example

    ```nix
    init [ 1 2 3 ]
    => [ 1 2 ]

    init [ "only" ]
    => [ ]
    ```

    :::
  */
  inherit (lib) init;

  /**
    Get the last element of a list.

    # Type

    ```
    last :: [a] -> a
    ```

    # Arguments

    xs
    : non-empty list

    # Examples

    :::{.example}
    ## `prelude.last` usage example

    ```nix
    last [ 1 2 3 ]
    => 3

    last [ "only" ]
    => "only"
    ```

    :::
  */
  inherit (lib) last;

  /**
    Take the first n elements of a list.

    # Type

    ```
    take :: int -> [a] -> [a]
    ```

    # Arguments

    n
    : number of elements to take

    xs
    : input list

    # Examples

    :::{.example}
    ## `prelude.take` usage example

    ```nix
    take 2 [ 1 2 3 4 5 ]
    => [ 1 2 ]

    take 10 [ 1 2 3 ]
    => [ 1 2 3 ]

    take 0 [ 1 2 3 ]
    => [ ]
    ```

    :::
  */
  inherit (lib) take;

  /**
    Drop the first n elements of a list.

    # Type

    ```
    drop :: int -> [a] -> [a]
    ```

    # Arguments

    n
    : number of elements to drop

    xs
    : input list

    # Examples

    :::{.example}
    ## `prelude.drop` usage example

    ```nix
    drop 2 [ 1 2 3 4 5 ]
    => [ 3 4 5 ]

    drop 10 [ 1 2 3 ]
    => [ ]

    drop 0 [ 1 2 3 ]
    => [ 1 2 3 ]
    ```

    :::
  */
  inherit (lib) drop;

  /**
    Get the length of a list.

    # Type

    ```
    length :: [a] -> int
    ```

    # Arguments

    xs
    : input list

    # Examples

    :::{.example}
    ## `prelude.length` usage example

    ```nix
    length [ 1 2 3 ]
    => 3

    length [ ]
    => 0
    ```

    :::
  */
  inherit (builtins) length;

  /**
    Reverse a list.

    # Type

    ```
    reverse :: [a] -> [a]
    ```

    # Arguments

    xs
    : input list

    # Examples

    :::{.example}
    ## `prelude.reverse` usage example

    ```nix
    reverse [ 1 2 3 ]
    => [ 3 2 1 ]

    reverse [ ]
    => [ ]
    ```

    :::
  */
  reverse = lib.reverseList;

  /**
    Concatenate a list of lists.

    # Type

    ```
    concat :: [[a]] -> [a]
    ```

    # Arguments

    xss
    : list of lists

    # Examples

    :::{.example}
    ## `prelude.concat` usage example

    ```nix
    concat [ [ 1 2 ] [ 3 4 ] [ 5 ] ]
    => [ 1 2 3 4 5 ]

    concat [ [ ] [ 1 ] [ ] ]
    => [ 1 ]
    ```

    :::
  */
  concat = lib.concatLists;

  /**
    Flatten a nested structure into a flat list.

    Recursively flattens lists and collects non-list elements.

    # Type

    ```
    flatten :: nested -> [a]
    ```

    # Arguments

    x
    : nested structure

    # Examples

    :::{.example}
    ## `prelude.flatten` usage example

    ```nix
    flatten [ 1 [ 2 [ 3 4 ] ] 5 ]
    => [ 1 2 3 4 5 ]

    flatten [ [ [ 1 ] ] ]
    => [ 1 ]
    ```

    :::
  */
  inherit (lib) flatten;

  /**
    Map a function over a list and concatenate the results.

    # Type

    ```
    concat-map :: (a -> [b]) -> [a] -> [b]
    ```

    # Arguments

    f
    : function returning a list

    xs
    : input list

    # Examples

    :::{.example}
    ## `prelude.concat-map` usage example

    ```nix
    concat-map (x: [ x (x * 2) ]) [ 1 2 3 ]
    => [ 1 2 2 4 3 6 ]

    concat-map (x: if x > 2 then [ x ] else [ ]) [ 1 2 3 4 ]
    => [ 3 4 ]
    ```

    :::
  */
  concat-map = lib.concatMap;

  /**
    Combine two lists into a list of pairs.

    # Type

    ```
    zip :: [a] -> [b] -> [{ fst :: a; snd :: b; }]
    ```

    # Arguments

    xs
    : first list

    ys
    : second list

    # Examples

    :::{.example}
    ## `prelude.zip` usage example

    ```nix
    zip [ 1 2 3 ] [ "a" "b" "c" ]
    => [ { fst = 1; snd = "a"; } { fst = 2; snd = "b"; } { fst = 3; snd = "c"; } ]

    zip [ 1 2 ] [ "a" "b" "c" ]
    => [ { fst = 1; snd = "a"; } { fst = 2; snd = "b"; } ]
    ```

    :::
  */
  zip =
    xs: ys:
    lib.zipListsWith (x: y: {
      fst = x;
      snd = y;
    }) xs ys;

  /**
    Combine two lists using a function.

    # Type

    ```
    zip-with :: (a -> b -> c) -> [a] -> [b] -> [c]
    ```

    # Arguments

    f
    : combining function

    xs
    : first list

    ys
    : second list

    # Examples

    :::{.example}
    ## `prelude.zip-with` usage example

    ```nix
    zip-with (a: b: a + b) [ 1 2 3 ] [ 10 20 30 ]
    => [ 11 22 33 ]

    zip-with (a: b: { name = a; value = b; }) [ "x" "y" ] [ 1 2 ]
    => [ { name = "x"; value = 1; } { name = "y"; value = 2; } ]
    ```

    :::
  */
  zip-with = lib.zipListsWith;

  /**
    Sort a list using a comparison function.

    # Type

    ```
    sort :: (a -> a -> bool) -> [a] -> [a]
    ```

    # Arguments

    cmp
    : comparison function returning true if first arg should come before second

    xs
    : list to sort

    # Examples

    :::{.example}
    ## `prelude.sort` usage example

    ```nix
    sort (a: b: a < b) [ 3 1 4 1 5 9 ]
    => [ 1 1 3 4 5 9 ]

    sort (a: b: a > b) [ 3 1 4 ]
    => [ 4 3 1 ]
    ```

    :::
  */
  inherit (builtins) sort;

  /**
    Remove duplicate elements from a list.

    # Type

    ```
    unique :: [a] -> [a]
    ```

    # Arguments

    xs
    : input list

    # Examples

    :::{.example}
    ## `prelude.unique` usage example

    ```nix
    unique [ 1 2 1 3 2 4 ]
    => [ 1 2 3 4 ]

    unique [ "a" "b" "a" ]
    => [ "a" "b" ]
    ```

    :::
  */
  inherit (lib) unique;

  /**
    Check if an element is in a list.

    # Type

    ```
    elem :: a -> [a] -> bool
    ```

    # Arguments

    x
    : element to find

    xs
    : list to search

    # Examples

    :::{.example}
    ## `prelude.elem` usage example

    ```nix
    elem 2 [ 1 2 3 ]
    => true

    elem 4 [ 1 2 3 ]
    => false
    ```

    :::
  */
  inherit (builtins) elem;

  /**
    Find the first element satisfying a predicate.

    Returns null if no element matches.

    # Type

    ```
    find :: (a -> bool) -> [a] -> a | null
    ```

    # Arguments

    pred
    : predicate function

    xs
    : list to search

    # Examples

    :::{.example}
    ## `prelude.find` usage example

    ```nix
    find (x: x > 3) [ 1 2 3 4 5 ]
    => 4

    find (x: x > 10) [ 1 2 3 ]
    => null
    ```

    :::
  */
  find = lib.findFirst;

  /**
    Split a list into elements that satisfy and don't satisfy a predicate.

    # Type

    ```
    partition :: (a -> bool) -> [a] -> { right :: [a]; wrong :: [a]; }
    ```

    # Arguments

    pred
    : predicate function

    xs
    : list to partition

    # Examples

    :::{.example}
    ## `prelude.partition` usage example

    ```nix
    partition (x: x > 2) [ 1 2 3 4 5 ]
    => { right = [ 3 4 5 ]; wrong = [ 1 2 ]; }
    ```

    :::
  */
  inherit (builtins) partition;

  /**
    Group list elements by a key function.

    # Type

    ```
    group-by :: (a -> string) -> [a] -> attrs
    ```

    # Arguments

    f
    : function to compute group key

    xs
    : list to group

    # Examples

    :::{.example}
    ## `prelude.group-by` usage example

    ```nix
    group-by (x: if x > 2 then "big" else "small") [ 1 2 3 4 ]
    => { big = [ 3 4 ]; small = [ 1 2 ]; }
    ```

    :::
  */
  group-by = builtins.groupBy;

  /**
    Generate a range of integers.

    # Type

    ```
    range :: int -> int -> [int]
    ```

    # Arguments

    start
    : first integer (inclusive)

    end
    : last integer (inclusive)

    # Examples

    :::{.example}
    ## `prelude.range` usage example

    ```nix
    range 1 5
    => [ 1 2 3 4 5 ]

    range 5 3
    => [ ]
    ```

    :::
  */
  inherit (lib) range;

  /**
    Create a list with n copies of a value.

    # Type

    ```
    replicate :: int -> a -> [a]
    ```

    # Arguments

    n
    : number of copies

    x
    : value to replicate

    # Examples

    :::{.example}
    ## `prelude.replicate` usage example

    ```nix
    replicate 3 "x"
    => [ "x" "x" "x" ]

    replicate 0 42
    => [ ]
    ```

    :::
  */
  inherit (lib) replicate;

  # ═══════════════════════════════════════════════════════════════════════════
  # Attrs
  # ═══════════════════════════════════════════════════════════════════════════

  /**
    Apply a function to each value in an attribute set.

    # Type

    ```
    map-attrs :: (string -> a -> b) -> attrs -> attrs
    ```

    # Arguments

    f
    : function taking key and value

    attrs
    : input attribute set

    # Examples

    :::{.example}
    ## `prelude.map-attrs` usage example

    ```nix
    map-attrs (n: v: v * 2) { a = 1; b = 2; }
    => { a = 2; b = 4; }
    ```

    :::
  */
  map-attrs = lib.mapAttrs;

  /**
    Keep only attributes satisfying a predicate.

    # Type

    ```
    filter-attrs :: (string -> a -> bool) -> attrs -> attrs
    ```

    # Arguments

    pred
    : predicate taking key and value

    attrs
    : input attribute set

    # Examples

    :::{.example}
    ## `prelude.filter-attrs` usage example

    ```nix
    filter-attrs (n: v: v > 1) { a = 1; b = 2; c = 3; }
    => { b = 2; c = 3; }
    ```

    :::
  */
  filter-attrs = lib.filterAttrs;

  /**
    Fold over an attribute set.

    # Type

    ```
    fold-attrs :: (b -> string -> a -> b) -> b -> attrs -> b
    ```

    # Arguments

    f
    : function (accumulator -> name -> value -> accumulator)

    init
    : initial accumulator

    attrs
    : attribute set to fold

    # Examples

    :::{.example}
    ## `prelude.fold-attrs` usage example

    ```nix
    fold-attrs (acc: n: v: acc + v) 0 { a = 1; b = 2; c = 3; }
    => 6
    ```

    :::
  */
  fold-attrs = lib.foldlAttrs;

  /**
    Get the keys of an attribute set.

    # Type

    ```
    keys :: attrs -> [string]
    ```

    # Arguments

    attrs
    : input attribute set

    # Examples

    :::{.example}
    ## `prelude.keys` usage example

    ```nix
    keys { a = 1; b = 2; }
    => [ "a" "b" ]
    ```

    :::
  */
  keys = builtins.attrNames;

  /**
    Get the values of an attribute set.

    # Type

    ```
    values :: attrs -> [a]
    ```

    # Arguments

    attrs
    : input attribute set

    # Examples

    :::{.example}
    ## `prelude.values` usage example

    ```nix
    values { a = 1; b = 2; }
    => [ 1 2 ]
    ```

    :::
  */
  values = builtins.attrValues;

  /**
    Check if an attribute set has a key.

    # Type

    ```
    has :: string -> attrs -> bool
    ```

    # Arguments

    key
    : attribute name to check

    attrs
    : attribute set to check

    # Examples

    :::{.example}
    ## `prelude.has` usage example

    ```nix
    has "a" { a = 1; b = 2; }
    => true

    has "c" { a = 1; b = 2; }
    => false
    ```

    :::
  */
  has = builtins.hasAttr;

  /**
    Get a nested attribute with a default value.

    # Type

    ```
    get :: [string] -> attrs -> a -> a
    ```

    # Arguments

    path
    : list of attribute names

    attrs
    : attribute set to query

    default
    : value to return if path doesn't exist

    # Examples

    :::{.example}
    ## `prelude.get` usage example

    ```nix
    get [ "a" "b" ] { a = { b = 42; }; } 0
    => 42

    get [ "a" "c" ] { a = { b = 42; }; } 0
    => 0
    ```

    :::
  */
  get = lib.attrByPath;

  /**
    Get an attribute, throwing if it doesn't exist.

    # Type

    ```
    get' :: string -> attrs -> a
    ```

    # Arguments

    key
    : attribute name

    attrs
    : attribute set

    # Examples

    :::{.example}
    ## `prelude.get'` usage example

    ```nix
    get' "a" { a = 1; b = 2; }
    => 1
    ```

    :::
  */
  get' = builtins.getAttr;

  /**
    Set a nested attribute.

    # Type

    ```
    set :: [string] -> a -> attrs -> attrs
    ```

    # Arguments

    path
    : list of attribute names

    value
    : value to set

    attrs
    : base attribute set

    # Examples

    :::{.example}
    ## `prelude.set` usage example

    ```nix
    set [ "a" "b" ] 42 { }
    => { a = { b = 42; }; }

    set [ "a" ] 1 { b = 2; }
    => { a = 1; b = 2; }
    ```

    :::
  */
  set = lib.setAttrByPath;

  /**
    Remove attributes from an attribute set.

    # Type

    ```
    remove :: [string] -> attrs -> attrs
    ```

    # Arguments

    names
    : list of attribute names to remove

    attrs
    : input attribute set

    # Examples

    :::{.example}
    ## `prelude.remove` usage example

    ```nix
    remove [ "a" "c" ] { a = 1; b = 2; c = 3; }
    => { b = 2; }
    ```

    :::
  */
  remove = builtins.removeAttrs;

  /**
    Merge two attribute sets (right wins).

    # Type

    ```
    merge :: attrs -> attrs -> attrs
    ```

    # Arguments

    a
    : first attribute set

    b
    : second attribute set (takes precedence)

    # Examples

    :::{.example}
    ## `prelude.merge` usage example

    ```nix
    merge { a = 1; b = 2; } { b = 3; c = 4; }
    => { a = 1; b = 3; c = 4; }
    ```

    :::
  */
  merge = a: b: a // b;

  /**
    Merge a list of attribute sets.

    # Type

    ```
    merge-all :: [attrs] -> attrs
    ```

    # Arguments

    attrsList
    : list of attribute sets

    # Examples

    :::{.example}
    ## `prelude.merge-all` usage example

    ```nix
    merge-all [ { a = 1; } { b = 2; } { c = 3; } ]
    => { a = 1; b = 2; c = 3; }
    ```

    :::
  */
  merge-all = lib.foldl' (a: b: a // b) { };

  /**
    Convert an attribute set to a list of name-value pairs.

    # Type

    ```
    to-list :: attrs -> [{ name :: string; value :: a; }]
    ```

    # Arguments

    attrs
    : input attribute set

    # Examples

    :::{.example}
    ## `prelude.to-list` usage example

    ```nix
    to-list { a = 1; b = 2; }
    => [ { name = "a"; value = 1; } { name = "b"; value = 2; } ]
    ```

    :::
  */
  to-list = lib.attrsToList;

  /**
    Convert a list of name-value pairs to an attribute set.

    # Type

    ```
    from-list :: [{ name :: string; value :: a; }] -> attrs
    ```

    # Arguments

    list
    : list of name-value pairs

    # Examples

    :::{.example}
    ## `prelude.from-list` usage example

    ```nix
    from-list [ { name = "a"; value = 1; } { name = "b"; value = 2; } ]
    => { a = 1; b = 2; }
    ```

    :::
  */
  from-list = builtins.listToAttrs;

  /**
    Map over an attribute set and collect results into a list.

    # Type

    ```
    map-to-list :: (string -> a -> b) -> attrs -> [b]
    ```

    # Arguments

    f
    : function taking name and value

    attrs
    : input attribute set

    # Examples

    :::{.example}
    ## `prelude.map-to-list` usage example

    ```nix
    map-to-list (n: v: "${n}=${toString v}") { a = 1; b = 2; }
    => [ "a=1" "b=2" ]
    ```

    :::
  */
  map-to-list = lib.mapAttrsToList;

  /**
    Keep only attributes that exist in both sets.

    # Type

    ```
    intersect :: attrs -> attrs -> attrs
    ```

    # Arguments

    a
    : first attribute set

    b
    : second attribute set

    # Examples

    :::{.example}
    ## `prelude.intersect` usage example

    ```nix
    intersect { a = 1; b = 2; c = 3; } { b = 20; c = 30; d = 40; }
    => { b = 2; c = 3; }
    ```

    :::
  */
  intersect = builtins.intersectAttrs;

  /**
    Generate an attribute set from a list of names.

    # Type

    ```
    gen-attrs :: [string] -> (string -> a) -> attrs
    ```

    # Arguments

    names
    : list of attribute names

    f
    : function to generate values

    # Examples

    :::{.example}
    ## `prelude.gen-attrs` usage example

    ```nix
    gen-attrs [ "a" "b" "c" ] (n: n + "!")
    => { a = "a!"; b = "b!"; c = "c!"; }
    ```

    :::
  */
  gen-attrs = lib.genAttrs;

  # ═══════════════════════════════════════════════════════════════════════════
  # Strings
  # ═══════════════════════════════════════════════════════════════════════════

  /**
    Split a string on a separator.

    # Type

    ```
    split :: string -> string -> [string]
    ```

    # Arguments

    sep
    : separator string

    str
    : string to split

    # Examples

    :::{.example}
    ## `prelude.split` usage example

    ```nix
    split "," "a,b,c"
    => [ "a" "b" "c" ]

    split "/" "/foo/bar"
    => [ "" "foo" "bar" ]
    ```

    :::
  */
  split = lib.splitString;

  /**
    Join a list of strings with a separator.

    # Type

    ```
    join :: string -> [string] -> string
    ```

    # Arguments

    sep
    : separator string

    strs
    : list of strings

    # Examples

    :::{.example}
    ## `prelude.join` usage example

    ```nix
    join ", " [ "a" "b" "c" ]
    => "a, b, c"

    join "" [ "hello" "world" ]
    => "helloworld"
    ```

    :::
  */
  join = builtins.concatStringsSep;

  /**
    Remove leading and trailing whitespace.

    # Type

    ```
    trim :: string -> string
    ```

    # Arguments

    str
    : input string

    # Examples

    :::{.example}
    ## `prelude.trim` usage example

    ```nix
    trim "  hello  "
    => "hello"

    trim "\n\tfoo\n"
    => "foo"
    ```

    :::
  */
  inherit (lib.strings) trim;

  /**
    Replace substrings.

    # Type

    ```
    replace :: [string] -> [string] -> string -> string
    ```

    # Arguments

    from
    : list of strings to replace

    to
    : list of replacement strings

    str
    : input string

    # Examples

    :::{.example}
    ## `prelude.replace` usage example

    ```nix
    replace [ "foo" ] [ "bar" ] "foo baz foo"
    => "bar baz bar"
    ```

    :::
  */
  replace = builtins.replaceStrings;

  /**
    Check if a string starts with a prefix.

    # Type

    ```
    starts-with :: string -> string -> bool
    ```

    # Arguments

    prefix
    : prefix to check for

    str
    : string to check

    # Examples

    :::{.example}
    ## `prelude.starts-with` usage example

    ```nix
    starts-with "hello" "hello world"
    => true

    starts-with "world" "hello world"
    => false
    ```

    :::
  */
  starts-with = lib.hasPrefix;

  /**
    Check if a string ends with a suffix.

    # Type

    ```
    ends-with :: string -> string -> bool
    ```

    # Arguments

    suffix
    : suffix to check for

    str
    : string to check

    # Examples

    :::{.example}
    ## `prelude.ends-with` usage example

    ```nix
    ends-with "world" "hello world"
    => true

    ends-with "hello" "hello world"
    => false
    ```

    :::
  */
  ends-with = lib.hasSuffix;

  /**
    Check if a string contains a substring.

    # Type

    ```
    contains :: string -> string -> bool
    ```

    # Arguments

    substr
    : substring to find

    str
    : string to search

    # Examples

    :::{.example}
    ## `prelude.contains` usage example

    ```nix
    contains "ell" "hello"
    => true

    contains "xyz" "hello"
    => false
    ```

    :::
  */
  contains = lib.hasInfix;

  /**
    Convert a string to lowercase.

    # Type

    ```
    to-lower :: string -> string
    ```

    # Arguments

    str
    : input string

    # Examples

    :::{.example}
    ## `prelude.to-lower` usage example

    ```nix
    to-lower "Hello World"
    => "hello world"
    ```

    :::
  */
  to-lower = lib.toLower;

  /**
    Convert a string to uppercase.

    # Type

    ```
    to-upper :: string -> string
    ```

    # Arguments

    str
    : input string

    # Examples

    :::{.example}
    ## `prelude.to-upper` usage example

    ```nix
    to-upper "Hello World"
    => "HELLO WORLD"
    ```

    :::
  */
  to-upper = lib.toUpper;

  /**
    Convert a value to a string.

    # Type

    ```
    to-string :: a -> string
    ```

    # Arguments

    x
    : value to convert

    # Examples

    :::{.example}
    ## `prelude.to-string` usage example

    ```nix
    to-string 42
    => "42"

    to-string true
    => "1"
    ```

    :::
  */
  to-string = builtins.toString;

  /**
    Get the length of a string.

    # Type

    ```
    string-length :: string -> int
    ```

    # Arguments

    str
    : input string

    # Examples

    :::{.example}
    ## `prelude.string-length` usage example

    ```nix
    string-length "hello"
    => 5
    ```

    :::
  */
  string-length = builtins.stringLength;

  /**
    Extract a substring.

    # Type

    ```
    substring :: int -> int -> string -> string
    ```

    # Arguments

    start
    : starting position (0-indexed)

    len
    : number of characters

    str
    : input string

    # Examples

    :::{.example}
    ## `prelude.substring` usage example

    ```nix
    substring 0 5 "hello world"
    => "hello"

    substring 6 5 "hello world"
    => "world"
    ```

    :::
  */
  inherit (builtins) substring;

  # ═══════════════════════════════════════════════════════════════════════════
  # Maybe (null handling)
  # ═══════════════════════════════════════════════════════════════════════════

  /**
    Handle nullable values with a default and a function.

    # Type

    ```
    maybe :: b -> (a -> b) -> a | null -> b
    ```

    # Arguments

    default
    : value to return if null

    f
    : function to apply if not null

    x
    : nullable value

    # Examples

    :::{.example}
    ## `prelude.maybe` usage example

    ```nix
    maybe 0 (x: x * 2) 5
    => 10

    maybe 0 (x: x * 2) null
    => 0
    ```

    :::
  */
  maybe =
    default: f: x:
    if x == null then default else f x;

  /**
    Extract value from nullable with a default.

    # Type

    ```
    from-maybe :: a -> a | null -> a
    ```

    # Arguments

    default
    : value to return if null

    x
    : nullable value

    # Examples

    :::{.example}
    ## `prelude.from-maybe` usage example

    ```nix
    from-maybe 42 null
    => 42

    from-maybe 42 100
    => 100
    ```

    :::
  */
  from-maybe = default: x: if x == null then default else x;

  /**
    Check if a value is null.

    # Type

    ```
    is-null :: a | null -> bool
    ```

    # Arguments

    x
    : value to check

    # Examples

    :::{.example}
    ## `prelude.is-null` usage example

    ```nix
    is-null null
    => true

    is-null 42
    => false
    ```

    :::
  */
  is-null = x: x == null;

  /**
    Filter null values from a list.

    # Type

    ```
    cat-maybes :: [a | null] -> [a]
    ```

    # Arguments

    xs
    : list possibly containing nulls

    # Examples

    :::{.example}
    ## `prelude.cat-maybes` usage example

    ```nix
    cat-maybes [ 1 null 2 null 3 ]
    => [ 1 2 3 ]
    ```

    :::
  */
  cat-maybes = filter (x: x != null);

  /**
    Map a function that may return null, filtering out nulls.

    # Type

    ```
    map-maybe :: (a -> b | null) -> [a] -> [b]
    ```

    # Arguments

    f
    : function that may return null

    xs
    : input list

    # Examples

    :::{.example}
    ## `prelude.map-maybe` usage example

    ```nix
    map-maybe (x: if x > 2 then x * 10 else null) [ 1 2 3 4 ]
    => [ 30 40 ]
    ```

    :::
  */
  map-maybe = f: xs: cat-maybes (map f xs);

  # ═══════════════════════════════════════════════════════════════════════════
  # Either
  # ═══════════════════════════════════════════════════════════════════════════

  /**
    Create a Left value (typically representing failure).

    # Type

    ```
    left :: a -> { _tag :: "left"; value :: a; }
    ```

    # Arguments

    x
    : value to wrap

    # Examples

    :::{.example}
    ## `prelude.left` usage example

    ```nix
    left "error"
    => { _tag = "left"; value = "error"; }
    ```

    :::
  */
  left = x: {
    _tag = "left";
    value = x;
  };

  /**
    Create a Right value (typically representing success).

    # Type

    ```
    right :: a -> { _tag :: "right"; value :: a; }
    ```

    # Arguments

    x
    : value to wrap

    # Examples

    :::{.example}
    ## `prelude.right` usage example

    ```nix
    right 42
    => { _tag = "right"; value = 42; }
    ```

    :::
  */
  right = x: {
    _tag = "right";
    value = x;
  };

  /**
    Check if an Either is a Left.

    # Type

    ```
    is-left :: Either a b -> bool
    ```

    # Arguments

    e
    : either value

    # Examples

    :::{.example}
    ## `prelude.is-left` usage example

    ```nix
    is-left (left "error")
    => true

    is-left (right 42)
    => false
    ```

    :::
  */
  is-left = e: e._tag == "left";

  /**
    Check if an Either is a Right.

    # Type

    ```
    is-right :: Either a b -> bool
    ```

    # Arguments

    e
    : either value

    # Examples

    :::{.example}
    ## `prelude.is-right` usage example

    ```nix
    is-right (right 42)
    => true

    is-right (left "error")
    => false
    ```

    :::
  */
  is-right = e: e._tag == "right";

  /**
    Apply one of two functions depending on Left or Right.

    # Type

    ```
    either :: (a -> c) -> (b -> c) -> Either a b -> c
    ```

    # Arguments

    on-left
    : function for Left values

    on-right
    : function for Right values

    e
    : either value

    # Examples

    :::{.example}
    ## `prelude.either` usage example

    ```nix
    either (e: "Error: " + e) (v: "Value: " + toString v) (right 42)
    => "Value: 42"

    either (e: "Error: " + e) (v: "Value: " + toString v) (left "oops")
    => "Error: oops"
    ```

    :::
  */
  either =
    on-left: on-right: e:
    if e._tag == "left" then on-left e.value else on-right e.value;

  /**
    Extract value from Right with a default.

    # Type

    ```
    from-right :: b -> Either a b -> b
    ```

    # Arguments

    default
    : value if Left

    e
    : either value

    # Examples

    :::{.example}
    ## `prelude.from-right` usage example

    ```nix
    from-right 0 (right 42)
    => 42

    from-right 0 (left "error")
    => 0
    ```

    :::
  */
  from-right = default: e: if e._tag == "right" then e.value else default;

  /**
    Extract value from Left with a default.

    # Type

    ```
    from-left :: a -> Either a b -> a
    ```

    # Arguments

    default
    : value if Right

    e
    : either value

    # Examples

    :::{.example}
    ## `prelude.from-left` usage example

    ```nix
    from-left "" (left "error")
    => "error"

    from-left "" (right 42)
    => ""
    ```

    :::
  */
  from-left = default: e: if e._tag == "left" then e.value else default;

  # ═══════════════════════════════════════════════════════════════════════════
  # Comparison
  # ═══════════════════════════════════════════════════════════════════════════

  /**
    Check equality.

    # Type

    ```
    eq :: a -> a -> bool
    ```

    # Arguments

    a
    : first value

    b
    : second value

    # Examples

    :::{.example}
    ## `prelude.eq` usage example

    ```nix
    eq 1 1
    => true

    eq "a" "b"
    => false
    ```

    :::
  */
  eq = a: b: a == b;

  /**
    Check inequality.

    # Type

    ```
    neq :: a -> a -> bool
    ```

    # Arguments

    a
    : first value

    b
    : second value

    # Examples

    :::{.example}
    ## `prelude.neq` usage example

    ```nix
    neq 1 2
    => true

    neq "a" "a"
    => false
    ```

    :::
  */
  neq = a: b: a != b;

  /**
    Less than comparison.

    # Type

    ```
    lt :: a -> a -> bool
    ```

    # Arguments

    a
    : first value

    b
    : second value

    # Examples

    :::{.example}
    ## `prelude.lt` usage example

    ```nix
    lt 1 2
    => true

    lt 2 1
    => false
    ```

    :::
  */
  lt = a: b: a < b;

  /**
    Less than or equal comparison.

    # Type

    ```
    le :: a -> a -> bool
    ```

    # Arguments

    a
    : first value

    b
    : second value

    # Examples

    :::{.example}
    ## `prelude.le` usage example

    ```nix
    le 1 2
    => true

    le 2 2
    => true
    ```

    :::
  */
  le = a: b: a <= b;

  /**
    Greater than comparison.

    # Type

    ```
    gt :: a -> a -> bool
    ```

    # Arguments

    a
    : first value

    b
    : second value

    # Examples

    :::{.example}
    ## `prelude.gt` usage example

    ```nix
    gt 2 1
    => true

    gt 1 2
    => false
    ```

    :::
  */
  gt = a: b: a > b;

  /**
    Greater than or equal comparison.

    # Type

    ```
    ge :: a -> a -> bool
    ```

    # Arguments

    a
    : first value

    b
    : second value

    # Examples

    :::{.example}
    ## `prelude.ge` usage example

    ```nix
    ge 2 1
    => true

    ge 2 2
    => true
    ```

    :::
  */
  ge = a: b: a >= b;

  /**
    Return the smaller of two values.

    # Type

    ```
    min :: a -> a -> a
    ```

    # Arguments

    a
    : first value

    b
    : second value

    # Examples

    :::{.example}
    ## `prelude.min` usage example

    ```nix
    min 1 2
    => 1

    min "b" "a"
    => "a"
    ```

    :::
  */
  inherit (lib) min;

  /**
    Return the larger of two values.

    # Type

    ```
    max :: a -> a -> a
    ```

    # Arguments

    a
    : first value

    b
    : second value

    # Examples

    :::{.example}
    ## `prelude.max` usage example

    ```nix
    max 1 2
    => 2

    max "a" "b"
    => "b"
    ```

    :::
  */
  inherit (lib) max;

  /**
    Three-way comparison returning -1, 0, or 1.

    # Type

    ```
    compare :: a -> a -> int
    ```

    # Arguments

    a
    : first value

    b
    : second value

    # Examples

    :::{.example}
    ## `prelude.compare` usage example

    ```nix
    compare 1 2
    => -1

    compare 2 2
    => 0

    compare 3 2
    => 1
    ```

    :::
  */
  compare =
    a: b:
    if a < b then
      -1
    else if a > b then
      1
    else
      0;

  /**
    Clamp a value to a range.

    # Type

    ```
    clamp :: a -> a -> a -> a
    ```

    # Arguments

    lo
    : minimum value

    hi
    : maximum value

    x
    : value to clamp

    # Examples

    :::{.example}
    ## `prelude.clamp` usage example

    ```nix
    clamp 0 10 5
    => 5

    clamp 0 10 15
    => 10

    clamp 0 10 (-5)
    => 0
    ```

    :::
  */
  clamp =
    lo: hi: x:
    if x < lo then
      lo
    else if x > hi then
      hi
    else
      x;

  # ═══════════════════════════════════════════════════════════════════════════
  # Boolean
  # ═══════════════════════════════════════════════════════════════════════════

  /**
    Boolean negation.

    # Type

    ```
    not :: bool -> bool
    ```

    # Arguments

    x
    : boolean to negate

    # Examples

    :::{.example}
    ## `prelude.not` usage example

    ```nix
    not true
    => false

    not false
    => true
    ```

    :::
  */
  not = x: !x;

  /**
    Boolean AND.

    # Type

    ```
    and :: bool -> bool -> bool
    ```

    # Arguments

    a
    : first boolean

    b
    : second boolean

    # Examples

    :::{.example}
    ## `prelude.and` usage example

    ```nix
    and true true
    => true

    and true false
    => false
    ```

    :::
  */
  and = a: b: a && b;

  /**
    Boolean OR.

    # Type

    ```
    or :: bool -> bool -> bool
    ```

    # Arguments

    a
    : first boolean

    b
    : second boolean

    # Examples

    :::{.example}
    ## `prelude.or` usage example

    ```nix
    or false true
    => true

    or false false
    => false
    ```

    :::
  */
  or = a: b: a || b;

  /**
    Check if all elements satisfy a predicate.

    # Type

    ```
    all :: (a -> bool) -> [a] -> bool
    ```

    # Arguments

    pred
    : predicate function

    xs
    : list to check

    # Examples

    :::{.example}
    ## `prelude.all` usage example

    ```nix
    all (x: x > 0) [ 1 2 3 ]
    => true

    all (x: x > 2) [ 1 2 3 ]
    => false
    ```

    :::
  */
  inherit (lib) all;

  /**
    Check if any element satisfies a predicate.

    # Type

    ```
    any :: (a -> bool) -> [a] -> bool
    ```

    # Arguments

    pred
    : predicate function

    xs
    : list to check

    # Examples

    :::{.example}
    ## `prelude.any` usage example

    ```nix
    any (x: x > 2) [ 1 2 3 ]
    => true

    any (x: x > 5) [ 1 2 3 ]
    => false
    ```

    :::
  */
  inherit (lib) any;

  /**
    Convert a boolean to another type.

    # Type

    ```
    bool :: a -> a -> bool -> a
    ```

    # Arguments

    on-false
    : value if false

    on-true
    : value if true

    b
    : boolean to convert

    # Examples

    :::{.example}
    ## `prelude.bool` usage example

    ```nix
    bool "no" "yes" true
    => "yes"

    bool 0 1 false
    => 0
    ```

    :::
  */
  bool =
    on-false: on-true: b:
    if b then on-true else on-false;

  # ═══════════════════════════════════════════════════════════════════════════
  # Arithmetic
  # ═══════════════════════════════════════════════════════════════════════════

  /**
    Add two numbers.

    # Type

    ```
    add :: number -> number -> number
    ```

    # Arguments

    a
    : first number

    b
    : second number

    # Examples

    :::{.example}
    ## `prelude.add` usage example

    ```nix
    add 1 2
    => 3
    ```

    :::
  */
  add = a: b: a + b;

  /**
    Subtract two numbers.

    # Type

    ```
    sub :: number -> number -> number
    ```

    # Arguments

    a
    : first number

    b
    : second number

    # Examples

    :::{.example}
    ## `prelude.sub` usage example

    ```nix
    sub 5 3
    => 2
    ```

    :::
  */
  sub = a: b: a - b;

  /**
    Multiply two numbers.

    # Type

    ```
    mul :: number -> number -> number
    ```

    # Arguments

    a
    : first number

    b
    : second number

    # Examples

    :::{.example}
    ## `prelude.mul` usage example

    ```nix
    mul 3 4
    => 12
    ```

    :::
  */
  mul = a: b: a * b;

  /**
    Divide two numbers.

    # Type

    ```
    div :: number -> number -> number
    ```

    # Arguments

    a
    : dividend

    b
    : divisor

    # Examples

    :::{.example}
    ## `prelude.div` usage example

    ```nix
    div 10 3
    => 3

    div 10.0 3.0
    => 3.333...
    ```

    :::
  */
  div = a: b: a / b;

  /**
    Integer modulo.

    # Type

    ```
    mod :: int -> int -> int
    ```

    # Arguments

    a
    : dividend

    b
    : divisor

    # Examples

    :::{.example}
    ## `prelude.mod` usage example

    ```nix
    mod 10 3
    => 1

    mod 9 3
    => 0
    ```

    :::
  */
  inherit (lib) mod;

  /**
    Negate a number.

    # Type

    ```
    neg :: number -> number
    ```

    # Arguments

    x
    : number to negate

    # Examples

    :::{.example}
    ## `prelude.neg` usage example

    ```nix
    neg 5
    => -5

    neg (-3)
    => 3
    ```

    :::
  */
  neg = x: -x;

  /**
    Absolute value.

    # Type

    ```
    abs :: number -> number
    ```

    # Arguments

    x
    : input number

    # Examples

    :::{.example}
    ## `prelude.abs` usage example

    ```nix
    abs (-5)
    => 5

    abs 3
    => 3
    ```

    :::
  */
  abs = x: if x < 0 then -x else x;

  /**
    Sum a list of numbers.

    # Type

    ```
    sum :: [number] -> number
    ```

    # Arguments

    xs
    : list of numbers

    # Examples

    :::{.example}
    ## `prelude.sum` usage example

    ```nix
    sum [ 1 2 3 4 ]
    => 10

    sum [ ]
    => 0
    ```

    :::
  */
  sum = fold add 0;

  /**
    Product of a list of numbers.

    # Type

    ```
    product :: [number] -> number
    ```

    # Arguments

    xs
    : list of numbers

    # Examples

    :::{.example}
    ## `prelude.product` usage example

    ```nix
    product [ 1 2 3 4 ]
    => 24

    product [ ]
    => 1
    ```

    :::
  */
  product = fold mul 1;

  # ═══════════════════════════════════════════════════════════════════════════
  # Type predicates
  # ═══════════════════════════════════════════════════════════════════════════

  /**
    Check if a value is a list.

    # Type

    ```
    is-list :: a -> bool
    ```

    # Arguments

    x
    : value to check

    # Examples

    :::{.example}
    ## `prelude.is-list` usage example

    ```nix
    is-list [ 1 2 3 ]
    => true

    is-list { }
    => false
    ```

    :::
  */
  is-list = builtins.isList;

  /**
    Check if a value is an attribute set.

    # Type

    ```
    is-attrs :: a -> bool
    ```

    # Arguments

    x
    : value to check

    # Examples

    :::{.example}
    ## `prelude.is-attrs` usage example

    ```nix
    is-attrs { a = 1; }
    => true

    is-attrs [ ]
    => false
    ```

    :::
  */
  is-attrs = builtins.isAttrs;

  /**
    Check if a value is a string.

    # Type

    ```
    is-string :: a -> bool
    ```

    # Arguments

    x
    : value to check

    # Examples

    :::{.example}
    ## `prelude.is-string` usage example

    ```nix
    is-string "hello"
    => true

    is-string 42
    => false
    ```

    :::
  */
  is-string = builtins.isString;

  /**
    Check if a value is an integer.

    # Type

    ```
    is-int :: a -> bool
    ```

    # Arguments

    x
    : value to check

    # Examples

    :::{.example}
    ## `prelude.is-int` usage example

    ```nix
    is-int 42
    => true

    is-int 3.14
    => false
    ```

    :::
  */
  is-int = builtins.isInt;

  /**
    Check if a value is a boolean.

    # Type

    ```
    is-bool :: a -> bool
    ```

    # Arguments

    x
    : value to check

    # Examples

    :::{.example}
    ## `prelude.is-bool` usage example

    ```nix
    is-bool true
    => true

    is-bool 1
    => false
    ```

    :::
  */
  is-bool = builtins.isBool;

  /**
    Check if a value is a float.

    # Type

    ```
    is-float :: a -> bool
    ```

    # Arguments

    x
    : value to check

    # Examples

    :::{.example}
    ## `prelude.is-float` usage example

    ```nix
    is-float 3.14
    => true

    is-float 42
    => false
    ```

    :::
  */
  is-float = builtins.isFloat;

  /**
    Check if a value is a path.

    # Type

    ```
    is-path :: a -> bool
    ```

    # Arguments

    x
    : value to check

    # Examples

    :::{.example}
    ## `prelude.is-path` usage example

    ```nix
    is-path ./foo
    => true

    is-path "/foo"
    => false
    ```

    :::
  */
  is-path = builtins.isPath;

  /**
    Check if a value is a function.

    # Type

    ```
    is-function :: a -> bool
    ```

    # Arguments

    x
    : value to check

    # Examples

    :::{.example}
    ## `prelude.is-function` usage example

    ```nix
    is-function (x: x)
    => true

    is-function 42
    => false
    ```

    :::
  */
  is-function = builtins.isFunction;

  /**
    Get the type of a value as a string.

    # Type

    ```
    typeof :: a -> string
    ```

    # Arguments

    x
    : value to inspect

    # Examples

    :::{.example}
    ## `prelude.typeof` usage example

    ```nix
    typeof 42
    => "int"

    typeof [ ]
    => "list"

    typeof { }
    => "set"
    ```

    :::
  */
  typeof = builtins.typeOf;
}
