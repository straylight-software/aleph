{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

-- |
-- Module      : Render.Emit.Config
-- Description : Generate emit-config bash function
--
-- The key innovation of render.nix: generating bash functions that output
-- structured config (JSON/YAML/TOML) based on config.* assignments.
--
-- Instead of heredoc templating:
-- @
-- cat << EOF > config.json
-- {
--   "server": {
--     "port": ${PORT},
--     "host": "${HOST}"
--   }
-- }
-- EOF
-- @
--
-- You write:
-- @
-- config.server.port=$PORT
-- config.server.host="$HOST"
-- emit-config json > config.json
-- @
--
-- The emit-config function is generated at build time with the correct
-- structure based on static analysis. Type safety is enforced: unquoted
-- values become JSON numbers/booleans, quoted become strings.
module Render.Emit.Config
  ( -- * Generation
    emitConfigFunction,
    emitConfigJson,
    emitConfigYaml,
    emitConfigToml,

    -- * Schema helpers
    ConfigTree (..),
    buildConfigTree,
  )
where

import Data.List (intersperse, sortOn)
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Data.Text (Text)
import qualified Data.Text as T
import Render.Types

-- | A tree representation of config structure
-- config.server.port -> ConfigLeaf "server" (ConfigLeaf "port" (ConfigValue ...))
data ConfigTree
  = ConfigBranch !(Map Text ConfigTree)
  | ConfigLeaf !ConfigSpec
  deriving (Eq, Show)

-- | Build a config tree from flat config specs
-- [["server", "port"]] -> { server: { port: ... } }
buildConfigTree :: Map ConfigPath ConfigSpec -> ConfigTree
buildConfigTree specs = foldr insertPath (ConfigBranch Map.empty) (Map.toList specs)
  where
    insertPath ([], spec) _ = ConfigLeaf spec
    insertPath (k : ks, spec) (ConfigBranch m) =
      ConfigBranch $ Map.alter (Just . go ks spec) k m
    insertPath _ leaf = leaf -- shouldn't happen

    go [] spec Nothing = ConfigLeaf spec
    go [] spec (Just _) = ConfigLeaf spec -- overwrite
    go (k : ks) spec Nothing =
      ConfigBranch $ Map.singleton k (go ks spec Nothing)
    go (k : ks) spec (Just (ConfigBranch m)) =
      ConfigBranch $ Map.alter (Just . go ks spec) k m
    go _ spec (Just leaf) = leaf -- can't descend into leaf

-- | Generate the emit-config bash function
-- This function will be injected into the script at build time
emitConfigFunction :: Schema -> Text
emitConfigFunction schema =
  T.unlines
    [ "# Generated by render.nix - do not edit",
      "emit-config() {",
      "  local format=\"${1:-json}\"",
      "  case \"$format\" in",
      "    json)",
      "      " <> emitConfigJson schema,
      "      ;;",
      "    yaml)",
      "      " <> emitConfigYaml schema,
      "      ;;",
      "    toml)",
      "      " <> emitConfigToml schema,
      "      ;;",
      "    *)",
      "      echo \"Unknown format: $format\" >&2",
      "      return 1",
      "      ;;",
      "  esac",
      "}"
    ]

-- | Generate JSON output command
emitConfigJson :: Schema -> Text
emitConfigJson schema =
  let tree = buildConfigTree (schemaConfig schema)
   in "cat << 'RENDER_EOF'\n" <> renderJsonTree 0 tree <> "\nRENDER_EOF"

-- | Render config tree as JSON
renderJsonTree :: Int -> ConfigTree -> Text
renderJsonTree indent = \case
  ConfigBranch m | Map.null m -> "{}"
  ConfigBranch m ->
    let entries = Map.toList m
        rendered = map (renderEntry indent) entries
        indentStr = T.replicate indent "  "
        nextIndent = T.replicate (indent + 1) "  "
     in "{\n"
          <> T.intercalate ",\n" (map (nextIndent <>) rendered)
          <> "\n"
          <> indentStr
          <> "}"
  ConfigLeaf spec -> renderJsonValue spec
  where
    renderEntry ind (key, subtree) =
      "\"" <> key <> "\": " <> renderJsonTree (ind + 1) subtree

-- | Render a config value as JSON
-- Uses bash variable expansion, with quoting based on type
renderJsonValue :: ConfigSpec -> Text
renderJsonValue ConfigSpec {..} = case cfgFrom of
  Just var -> case cfgType of
    TString -> "\"$" <> var <> "\""
    TInt -> "$" <> var
    TBool -> "$" <> var
    TNumeric -> "$" <> var
    TPath -> "\"$" <> var <> "\""
    TVar _ -> "\"$" <> var <> "\"" -- unknown defaults to string
  Nothing -> "null" -- literal with no source (shouldn't happen)

-- | Generate YAML output command
emitConfigYaml :: Schema -> Text
emitConfigYaml schema =
  let tree = buildConfigTree (schemaConfig schema)
   in "cat << 'RENDER_EOF'\n" <> renderYamlTree 0 tree <> "\nRENDER_EOF"

-- | Render config tree as YAML
renderYamlTree :: Int -> ConfigTree -> Text
renderYamlTree indent = \case
  ConfigBranch m | Map.null m -> "{}"
  ConfigBranch m ->
    let entries = sortOn fst (Map.toList m)
        rendered = map (renderYamlEntry indent) entries
     in T.intercalate "\n" rendered
  ConfigLeaf spec -> renderYamlValue spec
  where
    renderYamlEntry ind (key, subtree) =
      let indentStr = T.replicate ind "  "
       in case subtree of
            ConfigBranch _ ->
              indentStr <> key <> ":\n" <> renderYamlTree (ind + 1) subtree
            ConfigLeaf spec ->
              indentStr <> key <> ": " <> renderYamlValue spec

-- | Render a config value as YAML
renderYamlValue :: ConfigSpec -> Text
renderYamlValue ConfigSpec {..} = case cfgFrom of
  Just var -> case cfgType of
    TString -> "\"$" <> var <> "\""
    TInt -> "$" <> var
    TBool -> "$" <> var
    TNumeric -> "$" <> var
    TPath -> "\"$" <> var <> "\""
    TVar _ -> "\"$" <> var <> "\""
  Nothing -> "null"

-- | Generate TOML output command
emitConfigToml :: Schema -> Text
emitConfigToml schema =
  let tree = buildConfigTree (schemaConfig schema)
   in "cat << 'RENDER_EOF'\n" <> renderTomlTree [] tree <> "\nRENDER_EOF"

-- | Render config tree as TOML
renderTomlTree :: [Text] -> ConfigTree -> Text
renderTomlTree path = \case
  ConfigBranch m | Map.null m -> ""
  ConfigBranch m ->
    let -- Separate leaves (direct values) from branches (sections)
        (leaves, branches) = Map.partitionWithKey isLeaf m
        isLeaf _ (ConfigLeaf _) = True
        isLeaf _ _ = False
        -- Render section header if we have leaves and a path
        sectionHeader =
          if not (null path) && not (Map.null leaves)
            then "[" <> T.intercalate "." path <> "]\n"
            else ""
        -- Render leaf values
        leafLines =
          map renderTomlLeaf (sortOn fst (Map.toList leaves))
        -- Render subsections
        branchLines =
          map (renderTomlBranch path) (sortOn fst (Map.toList branches))
     in sectionHeader
          <> T.intercalate "\n" leafLines
          <> (if not (Map.null leaves) && not (Map.null branches) then "\n\n" else "")
          <> T.intercalate "\n\n" branchLines
  ConfigLeaf _ -> "" -- shouldn't be called at top level
  where
    renderTomlLeaf (key, ConfigLeaf spec) =
      key <> " = " <> renderTomlValue spec
    renderTomlLeaf _ = ""

    renderTomlBranch parentPath (key, subtree) =
      renderTomlTree (parentPath ++ [key]) subtree

-- | Render a config value as TOML
renderTomlValue :: ConfigSpec -> Text
renderTomlValue ConfigSpec {..} = case cfgFrom of
  Just var -> case cfgType of
    TString -> "\"$" <> var <> "\""
    TInt -> "$" <> var
    TBool -> "$" <> var -- TOML uses true/false
    TNumeric -> "$" <> var
    TPath -> "\"$" <> var <> "\""
    TVar _ -> "\"$" <> var <> "\""
  Nothing -> "null" -- not valid TOML but indicates issue
