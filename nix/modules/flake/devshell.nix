# nix/modules/flake/devshell.nix
#
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#                              // devshell //
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#
#     Case had always taken it for granted that the real bosses, the
#     kingpins in a given industry, would be old men. The Tessier-
#     Ashpools were old money. He'd expected a boardroom, an
#     executive's office. Not the surreal maze of Straylight.
#
#                                                         — Neuromancer
#
# Development shell. Env vars at mkShell level only, not in shellHook.
# We say "nv" not "cuda". See: docs/languages/nix/philosophy/nvidia-not-cuda.md
#
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
_:
{ config, lib, ... }:
let
  cfg = config.aleph-naught.devshell;
in
{
  _class = "flake";

  options.aleph-naught.devshell = {
    enable = lib.mkEnableOption "aleph-naught devshell";
    nv.enable = lib.mkEnableOption "NVIDIA SDK in devshell";
    ghc-wasm.enable = lib.mkEnableOption "GHC WASM backend (for builtins.wasm plugins)";
    straylight-nix.enable = lib.mkEnableOption "straylight-nix with builtins.wasm support";

    extra-packages = lib.mkOption {
      type = lib.types.functionTo (lib.types.listOf lib.types.package);
      default = _: [ ];
      description = "Extra packages (receives pkgs)";
    };

    extra-shell-hook = lib.mkOption {
      type = lib.types.lines;
      default = "";
      description = "Extra shell hook commands";
    };

    extra-env = lib.mkOption {
      type = lib.types.attrsOf lib.types.str;
      default = { };
      description = "Extra environment variables";
    };
  };

  config = lib.mkIf cfg.enable {
    perSystem =
      { pkgs, config, ... }:
      let
        # All env vars defined here, not in shellHook
        # Env var names use CUDA/NVIDIA because that's what tools expect
        nv-env = lib.optionalAttrs (cfg.nv.enable && pkgs ? nvidia-sdk) {
          CUDA_HOME = "${pkgs.nvidia-sdk}";
          CUDA_PATH = "${pkgs.nvidia-sdk}";
          NVIDIA_SDK = "${pkgs.nvidia-sdk}";
        };

        # Haskell: use ghc912 with all packages baked in via ghcWithPackages
        # No GHC_PACKAGE_PATH, no runtime package db - just a GHC that has everything
        #
        # HLS go-to-definition:
        # - For YOUR code: works via hie.yaml (generated in shellHook)
        # - For library code: HLS uses Haddock docs for type info, but source
        #   navigation requires packages built with -fwrite-ide-info (not default).
        #   For library source nav, use haskell-src-exts or M-. in Emacs haskell-mode.
        hsPkgs = pkgs.haskell.packages.ghc912 or pkgs.haskellPackages;

        # Packages for devshell GHC (interactive use, HLS, etc.)
        # Buck2 uses its own GHC from build.nix with its own package set
        ghcWithAllDeps = hsPkgs.ghcWithPackages (hp: [
          # Core
          hp.text
          hp.bytestring
          hp.containers
          hp.directory
          hp.filepath
          hp.process
          hp.time

          # CLI / scripting
          hp.aeson
          hp.aeson-pretty
          hp.optparse-applicative
          hp.turtle
          hp.megaparsec
          hp.prettyprinter
          hp.yaml

          # Testing
          hp.hedgehog
          hp.QuickCheck
          hp.quickcheck-instances
          hp.tasty
          hp.tasty-quickcheck
          hp.tasty-hunit

          # Other
          hp.lens
          hp.raw-strings-qq
        ]);

        # System libraries GHC needs at runtime
        ghcRuntimeLibs = [
          pkgs.numactl
          pkgs.gmp
          pkgs.libffi
          pkgs.ncurses
        ];
      in
      {
        devShells.default = pkgs.mkShell (
          {
            name = "straylight-dev";

            hardeningDisable = [ "all" ];
            NIX_HARDENING_ENABLE = "";

            packages = [
              pkgs.git
              pkgs.jq
              pkgs.yq-go
              pkgs.ripgrep
              pkgs.fd
              pkgs.just
              pkgs.buck2
              ghcWithAllDeps

              # ════════════════════════════════════════════════════════════════
              # LSP servers - go-to-definition works out of the box
              # ════════════════════════════════════════════════════════════════

              # Haskell: HLS with matching GHC version
              # Packages built with -fwrite-ide-info for library navigation
              hsPkgs.haskell-language-server

              # Nix: nixd (configured via .nixd.json from use_flake-lsp)
              pkgs.nixd

              # Rust: rust-analyzer (if Rust toolchain enabled)
              # Note: rust-analyzer is added via build.nix when rust toolchain is enabled
            ]
            # C++: clangd comes from llvm-git (via build.nix packages)
            # compile_commands.json generated by bin/compdb
            ++ ghcRuntimeLibs
            ++ lib.optionals (cfg.nv.enable && pkgs ? llvm-git) [
              pkgs.llvm-git
            ]
            ++ lib.optionals (!cfg.nv.enable && pkgs ? straylight && pkgs.straylight ? llvm) [
              pkgs.straylight.llvm.clang
              pkgs.straylight.llvm.lld
            ]
            ++ lib.optionals (cfg.nv.enable && pkgs ? nvidia-sdk) [
              pkgs.nvidia-sdk
            ]
            # GHC WASM toolchain for builtins.wasm plugin development
            ++ lib.optionals (cfg.ghc-wasm.enable && pkgs ? straylight && pkgs.straylight ? ghc-wasm) (
              let
                ghcWasm = pkgs.straylight.ghc-wasm;
              in
              lib.filter (p: p != null) [
                ghcWasm.ghc-wasm
                ghcWasm.ghc-wasm-cabal
                ghcWasm.wasi-sdk
                ghcWasm.wasm-wasmtime
              ]
            )
            # straylight-nix with builtins.wasm support
            ++ lib.optionals (cfg.straylight-nix.enable && pkgs ? straylight && pkgs.straylight ? nix) (
              lib.filter (p: p != null) [
                pkgs.straylight.nix.nix
              ]
            )
            ++ (cfg.extra-packages pkgs)
            # Buck2 build system packages (includes toolchain-specific LSPs like rust-analyzer)
            ++ (config.straylight.build.packages or [ ])
            # LRE packages (nativelink, lre-start)
            ++ (config.straylight.lre.packages or [ ]);

            shellHook = ''
                echo "━━━ aleph-naught devshell ━━━"

                # GHC packages are baked into ghcWithPackages - no runtime config needed
                # Buck2 uses its own GHC from .buckconfig.local with explicit -package flags
                echo "GHC: $(${ghcWithAllDeps}/bin/ghc --version)"
                ${lib.optionalString cfg.ghc-wasm.enable ''
                  if command -v wasm32-wasi-ghc &>/dev/null; then
                    echo "GHC-WASM: $(wasm32-wasi-ghc --version)"
                  fi
                ''}
                ${lib.optionalString cfg.straylight-nix.enable ''
                  if [ -n "${pkgs.straylight.nix.nix or ""}" ]; then
                    echo "straylight-nix: $(${pkgs.straylight.nix.nix}/bin/nix --version)"
                    echo "builtins.wasm: $(${pkgs.straylight.nix.nix}/bin/nix eval --expr 'builtins ? wasm')"
                  fi
                ''}
                # Buck2 build system integration
              ${config.straylight.build.shellHook or ""}

              # Shortlist hermetic C++ libraries
              ${config.straylight.shortlist.shellHook or ""}

              # Local Remote Execution (NativeLink)
              ${config.straylight.lre.shellHook or ""}

              ${cfg.extra-shell-hook}
            '';
          }
          // nv-env
          // cfg.extra-env
        );
        devShells.linter = pkgs.mkShell {
          name = "linter-shell";

          packages = [
            pkgs.ast-grep
            pkgs.tree-sitter
            pkgs.tree-sitter-grammars.tree-sitter-nix
          ];
        };
      };
  };
}
