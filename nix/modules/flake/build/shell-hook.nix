# nix/modules/flake/build/shell-hook.nix
#
# Shell hook for Buck2 setup (prelude linking, buckconfig generation, wrappers)
#
{
  lib,
  pkgs,
  cfg,
  inputs,
  buckconfig,
}:
let
  inherit (pkgs.stdenv) isLinux;
  scriptsDir = ./scripts;

  # Buck2 prelude source
  preludeSrc = if cfg.prelude.path != null then cfg.prelude.path else inputs.buck2-prelude or null;

  # Toolchains source (from this flake)
  toolchainsSrc = inputs.self + "/toolchains";

  # Read script files and substitute paths
  readScript = file: builtins.readFile (scriptsDir + "/${file}");

  # ────────────────────────────────────────────────────────────────────────────
  # Shell hook components
  # ────────────────────────────────────────────────────────────────────────────

  # Prelude and toolchains linking
  preludeHook = lib.optionalString (isLinux && cfg.prelude.enable && preludeSrc != null) (
    builtins.replaceStrings
      [
        "@preludeSrc@"
        "@toolchainsSrc@"
      ]
      [
        (toString preludeSrc)
        (toString toolchainsSrc)
      ]
      (readScript "shell-hook-prelude.bash")
  );

  # .buckconfig generation (main file, if enabled)
  buckconfigMainHook = lib.optionalString (isLinux && cfg.generate-buckconfig-main) (
    builtins.replaceStrings [ "@buckconfigMain@" ] [ (readScript "buckconfig-main.ini") ] (
      readScript "shell-hook-buckconfig-main.bash"
    )
  );

  # .buckconfig.local generation
  buckconfigLocalHook = lib.optionalString (isLinux && cfg.generate-buckconfig) ''
    # Generate .buckconfig.local with Nix store paths
    rm -f .buckconfig.local 2>/dev/null || true
    cp ${buckconfig.buckconfig-local} .buckconfig.local
    chmod 644 .buckconfig.local
    echo "Generated .buckconfig.local with Nix store paths"
  '';

  # Wrapper generation
  wrappersHook = lib.optionalString (isLinux && cfg.generate-wrappers) (
    ''
      # Generate bin/ wrappers for Buck2 toolchains
      mkdir -p bin

    ''
    + lib.optionalString cfg.toolchain.haskell.enable ''
      cp ${scriptsDir}/ghc-wrapper.bash bin/ghc
      chmod +x bin/ghc

      cat > bin/ghc-pkg << 'EOF'
      #!/usr/bin/env bash
      exec ghc-pkg "$@"
      EOF
      chmod +x bin/ghc-pkg

      cat > bin/haddock << 'EOF'
      #!/usr/bin/env bash
      exec haddock "$@"
      EOF
      chmod +x bin/haddock

      # Generate hie.yaml for HLS (go-to-definition support)
      if [ ! -e "hie.yaml" ]; then
        cat > hie.yaml << 'HIE_YAML_EOF'
      # HLS configuration for Buck2 Haskell projects
      # Generated by aleph.build module
      cradle:
        direct:
          arguments:
            - -Wall
            - -Wno-unused-imports
            - -isrc/haskell
            - -isrc/tools/compdb
            - -isrc/tools/scripts
            - -isrc/examples/haskell
      HIE_YAML_EOF
        echo "Generated hie.yaml for HLS"
      fi
    ''
    + lib.optionalString cfg.toolchain.lean.enable ''
      cp ${scriptsDir}/lean-wrapper.bash bin/lean
      chmod +x bin/lean

      cp ${scriptsDir}/leanc-wrapper.bash bin/leanc
      chmod +x bin/leanc
    ''
    + lib.optionalString cfg.toolchain.cxx.enable ''
      cp ${scriptsDir}/cxx-wrapper.bash bin/cxx
      chmod +x bin/cxx

      # compile_commands.json generator for clangd/clang-tidy
      cat > bin/compdb << 'COMPDB_EOF'
      #!/usr/bin/env bash
      # Generate compile_commands.json for clangd/clang-tidy
      set -euo pipefail
      TARGETS="''${@:-//...}"
      echo "Generating compile_commands.json for: $TARGETS"
      COMPDB_PATH=$(buck2 bxl prelude//cxx/tools/compilation_database.bxl:generate -- --targets $TARGETS 2>/dev/null | tail -1)
      if [ -n "$COMPDB_PATH" ] && [ -f "$COMPDB_PATH" ]; then
        cp "$COMPDB_PATH" compile_commands.json
        echo "Generated compile_commands.json ($(jq length compile_commands.json) entries)"
      else
        echo "Failed to generate compile_commands.json" >&2
        exit 1
      fi
      COMPDB_EOF
      chmod +x bin/compdb
    ''
    + ''
      echo "Generated bin/ wrappers for Buck2 toolchains"
    ''
  );

  # Auto-generate compile_commands.json
  compdbAutoHook =
    lib.optionalString
      (isLinux && cfg.toolchain.cxx.enable && cfg.compdb.enable && cfg.compdb.auto-generate)
      ''
        # Auto-generate compile_commands.json for clangd
        if command -v buck2 &>/dev/null; then
          echo "Generating compile_commands.json..."
          TARGETS="${lib.concatStringsSep " " cfg.compdb.targets}"
          COMPDB_PATH=$(buck2 bxl prelude//cxx/tools/compilation_database.bxl:generate -- --targets $TARGETS 2>/dev/null | tail -1) || true
          if [ -n "$COMPDB_PATH" ] && [ -f "$COMPDB_PATH" ]; then
            cp "$COMPDB_PATH" compile_commands.json
            echo "Generated compile_commands.json ($(jq length compile_commands.json 2>/dev/null || echo '?') entries)"
          fi
        fi
      '';
in
{
  shellHook = preludeHook + buckconfigMainHook + buckconfigLocalHook + wrappersHook + compdbAutoHook;
}
